{
  "name": "input-otp",
  "type": "registry:component",
  "files": [
    {
      "name": "input-otp-group.component.ts",
      "content": "import { ChangeDetectionStrategy, Component, computed, input } from '@angular/core';\n\nimport type { ClassValue } from 'clsx';\n\nimport { mergeClasses } from '@/shared/utils/merge-classes';\n\nimport { inputOtpGroupVariants } from './input-otp.variants';\n\n@Component({\n  selector: 'z-input-otp-group, [z-input-otp-group]',\n  template: `\n    <div [class]=\"classes()\">\n      <ng-content />\n    </div>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  host: {\n    '[attr.data-input-otp-group]': '\"\"',\n  },\n})\nexport class ZardInputOtpGroupComponent {\n  readonly class = input<ClassValue>('');\n\n  readonly classes = computed(() => mergeClasses(inputOtpGroupVariants(), this.class()));\n}\n"
    },
    {
      "name": "input-otp-separator.component.ts",
      "content": "import { ChangeDetectionStrategy, Component, computed, input } from '@angular/core';\n\nimport type { ClassValue } from 'clsx';\n\nimport { mergeClasses } from '@/shared/utils/merge-classes';\n\nimport { inputOtpSeparatorVariants } from './input-otp.variants';\n\n@Component({\n  selector: 'z-input-otp-separator, [z-input-otp-separator]',\n  template: `\n    <div [class]=\"classes()\" role=\"separator\">\n      <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        width=\"16\"\n        height=\"16\"\n        viewBox=\"0 0 24 24\"\n        fill=\"none\"\n        stroke=\"currentColor\"\n        stroke-width=\"2\"\n        stroke-linecap=\"round\"\n        stroke-linejoin=\"round\"\n      >\n        <line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\" />\n      </svg>\n    </div>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  host: {\n    '[attr.data-input-otp-separator]': '\"\"',\n  },\n})\nexport class ZardInputOtpSeparatorComponent {\n  readonly class = input<ClassValue>('');\n\n  readonly classes = computed(() => mergeClasses(inputOtpSeparatorVariants(), this.class()));\n}\n"
    },
    {
      "name": "input-otp-slot.component.ts",
      "content": "import {\n  ChangeDetectionStrategy,\n  Component,\n  computed,\n  type ElementRef,\n  inject,\n  input,\n  signal,\n  viewChild,\n} from '@angular/core';\n\nimport type { ClassValue } from 'clsx';\n\nimport { mergeClasses } from '@/shared/utils/merge-classes';\n\nimport { ZardInputOtpComponent } from './input-otp.component';\nimport { inputOtpSlotVariants } from './input-otp.variants';\n\n@Component({\n  selector: 'z-input-otp-slot, [z-input-otp-slot]',\n  template: `\n    <input\n      #slotInput\n      type=\"text\"\n      [value]=\"char()\"\n      [attr.maxlength]=\"1\"\n      [attr.inputmode]=\"inputOtp?.inputMode() || 'numeric'\"\n      [attr.autocomplete]=\"'one-time-code'\"\n      [disabled]=\"inputOtp?.disabled()\"\n      [readonly]=\"inputOtp?.zReadonly()\"\n      [class]=\"classes()\"\n      [attr.data-active]=\"isActive() ? '' : null\"\n      (input)=\"onInput($event)\"\n      (focus)=\"onFocus($event)\"\n      (blur)=\"onBlur()\"\n      (paste)=\"onPaste($event)\"\n      (keydown)=\"onKeyDown($event)\"\n    />\n    @if (hasFakeCaret() && !char()) {\n      <div class=\"pointer-events-none absolute inset-0 flex items-center justify-center\">\n        <div class=\"animate-caret-blink bg-foreground h-4 w-px\"></div>\n      </div>\n    }\n  `,\n  styles: `\n    @keyframes caret-blink {\n      0%,\n      70%,\n      100% {\n        opacity: 1;\n      }\n      20%,\n      50% {\n        opacity: 0;\n      }\n    }\n\n    .animate-caret-blink {\n      animation: caret-blink 1s ease-out infinite;\n    }\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  host: {\n    '[attr.data-slot]': '\"\"',\n    class: 'relative',\n  },\n})\nexport class ZardInputOtpSlotComponent {\n  readonly slotInputRef = viewChild.required<ElementRef<HTMLInputElement>>('slotInput');\n\n  inputOtp = inject(ZardInputOtpComponent, { optional: true });\n\n  readonly zIndex = input.required<number>();\n  readonly class = input<ClassValue>('');\n\n  readonly char = signal<string>('');\n  readonly isActive = signal<boolean>(false);\n  readonly hasFakeCaret = signal<boolean>(false);\n\n  readonly classes = computed(() => mergeClasses(inputOtpSlotVariants(), this.class()));\n\n  getInputElement(): HTMLInputElement {\n    return this.slotInputRef().nativeElement;\n  }\n\n  focus(): void {\n    const input = this.getInputElement();\n    input.focus();\n    input.select();\n  }\n\n  rejectInput(): void {\n    const input = this.getInputElement();\n    input.value = this.char();\n  }\n\n  onInput(event: Event): void {\n    const input = event.target as HTMLInputElement;\n    const { value } = input;\n\n    if (this.zIndex() === 0 && value.length > 1) {\n      this.inputOtp?.handlePaste(value);\n      event.stopPropagation();\n      return;\n    }\n\n    this.inputOtp?.onInput(event, this.zIndex());\n  }\n\n  onFocus(event: Event): void {\n    const input = event.target as HTMLInputElement;\n    input.select();\n    this.inputOtp?.onInputFocus(event, this.zIndex());\n  }\n\n  onBlur(): void {\n    this.inputOtp?.onInputBlur();\n  }\n\n  onPaste(event: ClipboardEvent): void {\n    if (this.inputOtp?.disabled() || this.inputOtp?.zReadonly()) {\n      return;\n    }\n\n    const paste = event.clipboardData?.getData('text');\n    if (paste?.length) {\n      this.inputOtp?.onPaste(event);\n    }\n\n    event.preventDefault();\n  }\n\n  onKeyDown(event: KeyboardEvent): void {\n    this.inputOtp?.onKeyDown(event);\n  }\n\n  updateState(char: string, isActive: boolean, hasFakeCaret: boolean): void {\n    this.char.set(char);\n    this.isActive.set(isActive);\n    this.hasFakeCaret.set(hasFakeCaret);\n\n    const input = this.getInputElement();\n    if (input) {\n      input.value = char;\n    }\n  }\n}\n"
    },
    {
      "name": "input-otp.component.ts",
      "content": "import {\n  type AfterContentInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  computed,\n  contentChildren,\n  type ElementRef,\n  forwardRef,\n  inject,\n  input,\n  output,\n  signal,\n  viewChildren,\n} from '@angular/core';\nimport { type ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\n\nimport type { ClassValue } from 'clsx';\n\nimport { mergeClasses } from '@/shared/utils/merge-classes';\n\nimport { ZardInputOtpSlotComponent } from './input-otp-slot.component';\nimport { inputOtpVariants } from './input-otp.variants';\n\ntype OnTouchedType = () => void;\ntype OnChangeType = (value: string) => void;\n\n@Component({\n  selector: 'z-input-otp, [z-input-otp]',\n  template: `\n    <div [class]=\"classes()\" [attr.data-input-otp-container]=\"''\">\n      @if (!hasSlots()) {\n        @for (i of getRange(); track i) {\n          <input\n            #otpInput\n            type=\"text\"\n            [value]=\"tokens[i - 1] || ''\"\n            [attr.maxlength]=\"1\"\n            [attr.inputmode]=\"inputMode()\"\n            [attr.autocomplete]=\"'one-time-code'\"\n            [disabled]=\"disabled()\"\n            [readonly]=\"zReadonly()\"\n            [class]=\"slotClasses(i - 1)\"\n            (input)=\"onInput($event, i - 1)\"\n            (focus)=\"onInputFocus($event, i - 1)\"\n            (blur)=\"onInputBlur()\"\n            (paste)=\"onPaste($event)\"\n            (keydown)=\"onKeyDown($event)\"\n          />\n        }\n      }\n      <ng-content />\n    </div>\n  `,\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => ZardInputOtpComponent),\n      multi: true,\n    },\n  ],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  host: {\n    '[attr.data-disabled]': 'disabled() ? \"\" : null',\n  },\n})\nexport class ZardInputOtpComponent implements ControlValueAccessor, AfterContentInit {\n  readonly inputs = viewChildren<ElementRef<HTMLInputElement>>('otpInput');\n\n  readonly zMaxLength = input<number | undefined>(undefined);\n  readonly zPattern = input<string>('[0-9]');\n  readonly zClass = input<ClassValue>('');\n  readonly zReadonly = input<boolean>(false);\n  readonly zIntegerOnly = input<boolean>(true);\n\n  zValueChange = output<string>();\n  zComplete = output<string>();\n\n  readonly slots = contentChildren(ZardInputOtpSlotComponent, { descendants: true });\n\n  tokens: string[] = [];\n  readonly disabled = signal<boolean>(false);\n  readonly focusedIndex = signal<number>(-1);\n  readonly classes = computed(() => mergeClasses(inputOtpVariants(), this.zClass()));\n  readonly inputMode = computed(() => (this.zIntegerOnly() ? 'numeric' : 'text'));\n\n  readonly hasSlots = signal(false);\n  readonly effectiveMaxLength = computed(() => this.zMaxLength() ?? (this.hasSlots() ? this.slots().length : 6));\n\n  private onTouched: OnTouchedType = () => {\n    /* empty */\n  };\n\n  private onChange: OnChangeType = () => {\n    /* empty */\n  };\n\n  private cd = inject(ChangeDetectorRef);\n\n  ngAfterContentInit(): void {\n    if (this.slots().length > 0) {\n      this.hasSlots.set(true);\n    }\n    this.cd.markForCheck();\n  }\n\n  slotClasses(index: number): string {\n    const baseClasses = [\n      'relative flex h-9 w-9 items-center justify-center',\n      'border-y border-r border-input text-sm transition-all text-center',\n      'bg-background',\n      'focus:z-10 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2',\n      'disabled:cursor-not-allowed disabled:opacity-50',\n      'placeholder:text-muted-foreground',\n    ];\n\n    if (index === 0) {\n      baseClasses.push('rounded-l-md border-l');\n    }\n\n    if (index === this.effectiveMaxLength() - 1) {\n      baseClasses.push('rounded-r-md');\n    }\n\n    return mergeClasses(baseClasses);\n  }\n\n  getRange(): number[] {\n    return Array.from({ length: this.effectiveMaxLength() }, (_, index) => index + 1);\n  }\n\n  writeValue(value: string): void {\n    if (value) {\n      const tokens: string[] = Array.isArray(value) ? value : String(value).split('');\n      this.tokens = tokens.slice(0, this.effectiveMaxLength());\n    } else {\n      this.tokens = [];\n    }\n    this.cd.markForCheck();\n  }\n\n  registerOnChange(fn: OnChangeType): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: OnTouchedType): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled.set(isDisabled);\n    this.cd.markForCheck();\n  }\n\n  onInput(event: Event, index: number): void {\n    const input = event.target as HTMLInputElement;\n    const { value } = input;\n\n    if (index === 0 && value.length > 1) {\n      this.handlePaste(value);\n      event.stopPropagation();\n      return;\n    }\n\n    const regex = new RegExp(this.zPattern());\n\n    if (value && !regex.test(value)) {\n      input.value = this.tokens[index] || '';\n      return;\n    }\n\n    this.tokens[index] = value;\n    this.updateModel();\n\n    const { inputType } = event as InputEvent;\n    if (inputType === 'deleteContentBackward') {\n      this.moveToPrev(event);\n    } else if (inputType === 'insertText' || inputType === 'deleteContentForward') {\n      this.moveToNext(event);\n    }\n  }\n\n  updateModel(): void {\n    const newValue = this.tokens.join('');\n    this.onChange(newValue);\n    this.zValueChange.emit(newValue);\n\n    if (newValue.length === this.zMaxLength()) {\n      this.zComplete.emit(newValue);\n    }\n\n    this.cd.markForCheck();\n  }\n\n  onInputFocus(event: Event, index: number): void {\n    const input = event.target as HTMLInputElement;\n    input.select();\n    this.focusedIndex.set(index);\n  }\n\n  onInputBlur(): void {\n    this.focusedIndex.set(-1);\n    this.onTouched();\n  }\n\n  onPaste(event: ClipboardEvent): void {\n    if (this.disabled() || this.zReadonly()) {\n      return;\n    }\n\n    const paste = event.clipboardData?.getData('text');\n    if (paste && paste.length) {\n      this.handlePaste(paste);\n    }\n\n    event.preventDefault();\n  }\n\n  handlePaste(paste: string): void {\n    const regex = new RegExp(this.zPattern());\n    const pastedCode = paste\n      .substring(0, this.effectiveMaxLength())\n      .split('')\n      .filter(char => regex.test(char))\n      .join('');\n\n    this.tokens = pastedCode.split('');\n    this.updateModel();\n\n    const nextIndex = Math.min(this.tokens.length, this.effectiveMaxLength() - 1);\n    const inputsArray = this.inputs();\n    if (inputsArray[nextIndex]) {\n      setTimeout(() => {\n        inputsArray[nextIndex].nativeElement.focus();\n      }, 0);\n    }\n  }\n\n  onKeyDown(event: KeyboardEvent): void {\n    if (event.altKey || event.ctrlKey || event.metaKey) {\n      return;\n    }\n\n    const input = event.target as HTMLInputElement;\n\n    switch (event.key) {\n      case 'ArrowLeft':\n        this.moveToPrev(event);\n        event.preventDefault();\n        break;\n\n      case 'ArrowUp':\n      case 'ArrowDown':\n        event.preventDefault();\n        break;\n\n      case 'Backspace':\n        if (input.value.length === 0) {\n          this.moveToPrev(event);\n          event.preventDefault();\n        }\n        break;\n\n      case 'ArrowRight':\n        this.moveToNext(event);\n        event.preventDefault();\n        break;\n\n      default: {\n        const hasSelection = input.selectionStart !== input.selectionEnd;\n        const isAtMaxLength = this.tokens.join('').length >= this.effectiveMaxLength();\n        const regex = new RegExp(this.zPattern());\n        const isValidKey = regex.test(event.key);\n\n        if (!isValidKey || (isAtMaxLength && event.key !== 'Delete' && !hasSelection)) {\n          event.preventDefault();\n        }\n        break;\n      }\n    }\n  }\n\n  moveToNext(event: Event): void {\n    const input = event.target as HTMLInputElement;\n    const nextInput = this.findNextInput(input);\n    if (nextInput) {\n      nextInput.focus();\n      nextInput.select();\n    }\n  }\n\n  moveToPrev(event: Event): void {\n    const input = event.target as HTMLInputElement;\n    const prevInput = this.findPrevInput(input);\n    if (prevInput) {\n      prevInput.focus();\n      prevInput.select();\n    }\n  }\n\n  findNextInput(element: HTMLElement): HTMLInputElement | null {\n    const nextElement = element.nextElementSibling;\n    if (!nextElement) {\n      const parent = element.parentElement;\n      if (!parent) {\n        return null;\n      }\n      return this.findNextInput(parent);\n    }\n\n    if (nextElement.nodeName === 'INPUT') {\n      return nextElement as HTMLInputElement;\n    }\n\n    const inputInside = nextElement.querySelector('input');\n    if (inputInside) {\n      return inputInside;\n    }\n\n    return this.findNextInput(nextElement as HTMLElement);\n  }\n\n  findPrevInput(element: HTMLElement): HTMLInputElement | null {\n    const prevElement = element.previousElementSibling;\n    if (!prevElement) {\n      const parent = element.parentElement;\n      if (!parent) {\n        return null;\n      }\n      return this.findPrevInput(parent);\n    }\n\n    if (prevElement.nodeName === 'INPUT') {\n      return prevElement as HTMLInputElement;\n    }\n\n    const inputs = prevElement.querySelectorAll('input');\n    if (inputs.length) {\n      return inputs[inputs.length - 1] as HTMLInputElement;\n    }\n\n    return this.findPrevInput(prevElement as HTMLElement);\n  }\n}\n"
    },
    {
      "name": "input-otp.variants.ts",
      "content": "import { cva, type VariantProps } from 'class-variance-authority';\n\nimport { mergeClasses } from '@/shared/utils/merge-classes';\n\nexport const inputOtpVariants = cva(mergeClasses('flex items-center has-[:disabled]:opacity-50'), {\n  variants: {\n    zSize: {\n      sm: 'gap-1 text-xs',\n      default: 'gap-2 text-sm',\n      lg: 'gap-3 text-base',\n    },\n  },\n  defaultVariants: {\n    zSize: 'default',\n  },\n});\n\nexport const inputOtpGroupVariants = cva(\n  mergeClasses(\n    'flex items-center',\n    '[&>z-input-otp-slot:first-child_input]:rounded-l-md [&>z-input-otp-slot:first-child_input]:border-l',\n    '[&>z-input-otp-slot:last-child_input]:rounded-r-md',\n  ),\n);\n\nexport const inputOtpSlotVariants = cva(\n  mergeClasses(\n    'relative flex items-center justify-center',\n    'border-y border-r border-input bg-transparent text-center',\n    'shadow-xs transition-[color,box-shadow] outline-none',\n    'focus:z-10 focus:border-ring focus:ring-ring/50 focus:ring-[3px]',\n    'disabled:cursor-not-allowed disabled:opacity-50',\n    'placeholder:text-muted-foreground',\n    'aria-invalid:border-destructive aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40',\n    'data-[active]:border-ring data-[active]:ring-ring/50 data-[active]:ring-[3px] data-[active]:z-10',\n  ),\n  {\n    variants: {\n      zSize: {\n        sm: 'h-8 w-8 text-xs',\n        default: 'h-9 w-9 text-sm',\n        lg: 'h-10 w-10 text-base',\n      },\n    },\n    defaultVariants: {\n      zSize: 'default',\n    },\n  },\n);\n\nexport const inputOtpSeparatorVariants = cva('flex items-center justify-center text-muted-foreground', {\n  variants: {\n    zSize: {\n      sm: '[&_svg]:size-3',\n      default: '[&_svg]:size-4',\n      lg: '[&_svg]:size-5',\n    },\n  },\n  defaultVariants: {\n    zSize: 'default',\n  },\n});\n\nexport type ZardInputOtpSizeVariants = NonNullable<VariantProps<typeof inputOtpVariants>['zSize']>;\nexport type ZardInputOtpSlotVariants = VariantProps<typeof inputOtpSlotVariants>;\nexport type ZardInputOtpGroupVariants = VariantProps<typeof inputOtpGroupVariants>;\nexport type ZardInputOtpSeparatorVariants = VariantProps<typeof inputOtpSeparatorVariants>;\n"
    },
    {
      "name": "index.ts",
      "content": "export * from './input-otp-group.component';\nexport * from './input-otp-separator.component';\nexport * from './input-otp-slot.component';\nexport * from './input-otp.component';\nexport * from './input-otp.variants';\n"
    }
  ]
}
