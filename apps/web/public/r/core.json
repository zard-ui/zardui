{
  "name": "core",
  "type": "registry:component",
  "files": [
    {
      "name": "directives/string-template-outlet/string-template-outlet.directive.ts",
      "content": "import {\n  Directive,\n  type EmbeddedViewRef,\n  inject,\n  input,\n  type OnDestroy,\n  TemplateRef,\n  ViewContainerRef,\n  effect,\n  type EffectRef,\n} from '@angular/core';\n\nexport function isTemplateRef<C = unknown>(value: unknown): value is TemplateRef<C> {\n  return value instanceof TemplateRef;\n}\n\nexport interface ZardStringTemplateOutletContext {\n  $implicit: unknown;\n  [key: string]: unknown;\n}\n\n@Directive({\n  selector: '[zStringTemplateOutlet]',\n  exportAs: 'zStringTemplateOutlet',\n})\nexport class ZardStringTemplateOutletDirective<T = unknown> implements OnDestroy {\n  private readonly viewContainer = inject(ViewContainerRef);\n  private readonly templateRef = inject(TemplateRef<void>);\n\n  private embeddedViewRef: EmbeddedViewRef<ZardStringTemplateOutletContext> | null = null;\n  private readonly context = {} as ZardStringTemplateOutletContext;\n\n  #isFirstChange = true;\n  #lastOutletWasTemplate = false;\n  #lastTemplateRef: TemplateRef<void> | null = null;\n  #lastContext?: ZardStringTemplateOutletContext;\n\n  readonly zStringTemplateOutletContext = input<ZardStringTemplateOutletContext | undefined>(undefined);\n  readonly zStringTemplateOutlet = input.required<T | TemplateRef<void>>();\n\n  #hasContextShapeChanged(context: ZardStringTemplateOutletContext | undefined): boolean {\n    if (!context) {\n      return false;\n    }\n    const prevCtxKeys = Object.keys(this.#lastContext || {});\n    const currCtxKeys = Object.keys(context || {});\n\n    if (prevCtxKeys.length === currCtxKeys.length) {\n      for (const propName of currCtxKeys) {\n        if (!prevCtxKeys.includes(propName)) {\n          return true;\n        }\n      }\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  #shouldViewBeRecreated(\n    stringTemplateOutlet: TemplateRef<void> | T,\n    stringTemplateOutletContext: ZardStringTemplateOutletContext | undefined,\n  ): boolean {\n    const isTemplate = isTemplateRef(stringTemplateOutlet);\n\n    const shouldOutletRecreate =\n      this.#isFirstChange ||\n      isTemplate !== this.#lastOutletWasTemplate ||\n      (isTemplate && stringTemplateOutlet !== this.#lastTemplateRef);\n\n    const shouldContextRecreate = this.#hasContextShapeChanged(stringTemplateOutletContext);\n    return shouldContextRecreate || shouldOutletRecreate;\n  }\n\n  #updateTrackingState(\n    stringTemplateOutlet: TemplateRef<void> | T,\n    stringTemplateOutletContext: ZardStringTemplateOutletContext | undefined,\n  ): void {\n    const isTemplate = isTemplateRef(stringTemplateOutlet);\n    if (this.#isFirstChange && !isTemplate) {\n      this.#isFirstChange = false;\n    }\n\n    if (stringTemplateOutletContext !== undefined) {\n      this.#lastContext = stringTemplateOutletContext;\n    }\n\n    this.#lastOutletWasTemplate = isTemplate;\n    this.#lastTemplateRef = isTemplate ? stringTemplateOutlet : null;\n  }\n\n  readonly #viewEffect: EffectRef = effect(() => {\n    const stringTemplateOutlet = this.zStringTemplateOutlet();\n    const stringTemplateOutletContext = this.zStringTemplateOutletContext();\n\n    if (!this.#isFirstChange && isTemplateRef(stringTemplateOutlet)) {\n      this.#isFirstChange = true;\n    }\n\n    if (!isTemplateRef(stringTemplateOutlet)) {\n      this.context['$implicit'] = stringTemplateOutlet as T;\n    }\n\n    const recreateView = this.#shouldViewBeRecreated(stringTemplateOutlet, stringTemplateOutletContext);\n    this.#updateTrackingState(stringTemplateOutlet, stringTemplateOutletContext);\n\n    if (recreateView) {\n      this.#recreateView(\n        stringTemplateOutlet as TemplateRef<ZardStringTemplateOutletContext>,\n        stringTemplateOutletContext,\n      );\n    } else {\n      this.#updateContext(stringTemplateOutlet, stringTemplateOutletContext);\n    }\n  });\n\n  #recreateView(\n    outlet: TemplateRef<ZardStringTemplateOutletContext>,\n    context: ZardStringTemplateOutletContext | undefined,\n  ): void {\n    this.viewContainer.clear();\n    if (isTemplateRef(outlet)) {\n      this.embeddedViewRef = this.viewContainer.createEmbeddedView(outlet, context);\n    } else {\n      this.embeddedViewRef = this.viewContainer.createEmbeddedView(this.templateRef, this.context);\n    }\n  }\n\n  #updateContext(outlet: TemplateRef<void> | T, context: ZardStringTemplateOutletContext | undefined): void {\n    const newCtx = isTemplateRef(outlet) ? context : this.context;\n    let oldCtx = this.embeddedViewRef?.context;\n\n    if (!oldCtx) {\n      oldCtx = newCtx;\n    } else if (newCtx && typeof newCtx === 'object') {\n      for (const propName of Object.keys(newCtx)) {\n        oldCtx[propName] = newCtx[propName];\n      }\n    }\n    this.#lastContext = oldCtx;\n  }\n\n  static ngTemplateContextGuard<T>(\n    _dir: ZardStringTemplateOutletDirective<T>,\n    _ctx: unknown,\n  ): _ctx is ZardStringTemplateOutletContext {\n    return true;\n  }\n\n  ngOnDestroy(): void {\n    this.#viewEffect.destroy();\n    this.viewContainer.clear();\n    this.embeddedViewRef = null;\n  }\n}\n"
    },
    {
      "name": "provider/event-manager-plugins/zard-debounce-event-manager-plugin.ts",
      "content": "import type { ListenerOptions } from '@angular/core';\nimport { EventManagerPlugin } from '@angular/platform-browser';\n\nexport class ZardDebounceEventManagerPlugin extends EventManagerPlugin {\n  override supports(eventName: string): boolean {\n    return /\\.debounce(?:\\.|$)/.test(eventName);\n  }\n\n  override addEventListener(\n    element: HTMLElement,\n    eventName: string,\n    handler: (event: Event) => void,\n    options?: ListenerOptions,\n    // eslint-disable-next-line\n  ): Function {\n    // Expected format: \"event.debounce.delay\" (e.g., \"input.debounce.150\")\n    // If delay is omitted or invalid, defaults to 300ms\n    const [event, , delay] = eventName.split('.');\n    const parsedDelay = Number.parseInt(delay);\n    const resolvedDelay = Number.isNaN(parsedDelay) ? 300 : parsedDelay;\n\n    let timeoutId!: ReturnType<typeof setTimeout>;\n    const listener = (event: Event) => {\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => handler(event), resolvedDelay);\n    };\n    const unsubscribe = this.manager.addEventListener(element, event, listener, options);\n    return () => {\n      clearTimeout(timeoutId);\n      unsubscribe();\n    };\n  }\n}\n"
    },
    {
      "name": "provider/event-manager-plugins/zard-event-manager-plugin.ts",
      "content": "import type { ListenerOptions } from '@angular/core';\nimport { EventManagerPlugin } from '@angular/platform-browser';\n\n/**\n * Angular EventManagerPlugin that provides event modifier syntax for templates.\n *\n * Supports modifiers: .prevent, .stop, .stop-immediate, .prevent-with-stop\n * Supports key filters: enter, escape, {enter,space}\n *\n * @example\n * Prevent default on any click\n * (click.prevent)=\"handler()\"\n *\n * @example\n * Prevent default only on Enter key\n * (keydown.enter.prevent)=\"handler()\"\n *\n * @example\n * Prevent default on more keys like Enter and Space key\n * (keydown.{enter,space}.prevent)=\"handler()\"\n *\n * @example\n * Stop propagation\n * (click.stop)=\"handler()\"\n */\nexport class ZardEventManagerPlugin extends EventManagerPlugin {\n  #keywords = ['prevent', 'stop', 'stop-immediate', 'prevent-with-stop'];\n\n  override supports(eventName: string): boolean {\n    return this.#keywords.some(keyword => eventName.endsWith(`.${keyword}`));\n  }\n\n  override addEventListener(\n    element: HTMLElement,\n    eventName: string,\n    handler: (event: Event) => void,\n    options?: ListenerOptions,\n    // eslint-disable-next-line\n  ): Function {\n    const { event, keyword, keys } = this.#provideEventFrom(eventName, this.#keywords);\n    return this.manager.addEventListener(\n      element,\n      event,\n      (event: Event) => {\n        const isKeyboardEvent = event instanceof KeyboardEvent;\n        const isElementDisabled = element.getAttribute('aria-disabled') === 'true';\n        const shouldApplyModifier =\n          (!keys.length || (isKeyboardEvent && keys.includes(event.key.toLowerCase()))) && !isElementDisabled;\n\n        if (shouldApplyModifier) {\n          switch (keyword) {\n            case 'stop':\n              event.stopPropagation();\n              break;\n            case 'stop-immediate':\n              event.stopImmediatePropagation();\n              break;\n            case 'prevent-with-stop':\n              event.preventDefault();\n              event.stopPropagation();\n              break;\n            default:\n              event.preventDefault();\n              break;\n          }\n        }\n        handler(event);\n      },\n      options,\n    );\n  }\n\n  #provideEventFrom(eventName: string, keywords: string[]): { event: string; keyword: string; keys: string[] } {\n    const eventNameSubstrings = eventName.split('.');\n    let event = '';\n    let keys: string[] = [];\n    let keyword = '';\n\n    for (const substring of eventNameSubstrings) {\n      if (substring.startsWith('{')) {\n        keys = this.#extractKeys(substring);\n        continue;\n      } else if (keywords.includes(substring)) {\n        keyword = substring;\n        break;\n      } else if (!event) {\n        event = substring;\n      } else {\n        event += `.${substring}`;\n      }\n    }\n\n    return { event, keyword, keys };\n  }\n\n  #extractKeys(substring: string): string[] {\n    const stringList = substring.substring(1, substring.length - 1);\n    return stringList\n      .split(',')\n      .map(raw => {\n        const s = raw.toLowerCase().trim();\n        return s === 'space' ? ' ' : s;\n      })\n      .filter(Boolean);\n  }\n}\n"
    },
    {
      "name": "provider/services/dark-mode.ts",
      "content": "import { isPlatformBrowser, DOCUMENT } from '@angular/common';\nimport { Injectable, type OnDestroy, PLATFORM_ID, computed, inject, signal } from '@angular/core';\n\nexport enum EDarkModes {\n  LIGHT = 'light',\n  DARK = 'dark',\n  SYSTEM = 'system',\n}\nexport type DarkModeOptions = EDarkModes.LIGHT | EDarkModes.DARK | EDarkModes.SYSTEM;\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class ZardDarkMode implements OnDestroy {\n  private readonly document = inject(DOCUMENT);\n\n  private static readonly STORAGE_KEY = 'theme';\n  private handleThemeChange = (event: MediaQueryListEvent) => this.updateThemeMode(event.matches);\n  private readonly isBrowser = isPlatformBrowser(inject(PLATFORM_ID));\n  private readonly themeSignal = signal<DarkModeOptions>(EDarkModes.SYSTEM);\n  private darkModeQuery?: MediaQueryList;\n\n  readonly theme = computed(() => this.themeSignal());\n\n  readonly themeMode = computed(() => {\n    if (this.themeSignal() === EDarkModes.SYSTEM) {\n      return this.isDarkMode() ? EDarkModes.DARK : EDarkModes.LIGHT;\n    }\n    return this.themeSignal();\n  });\n\n  ngOnDestroy(): void {\n    this.handleSystemChanges(false);\n  }\n\n  init(): void {\n    if (!this.isBrowser) {\n      return;\n    }\n\n    this.applyTheme(this.getStoredTheme() ?? EDarkModes.SYSTEM);\n  }\n\n  toggleTheme(): void {\n    const currentTheme = this.getCurrentTheme();\n    if (!this.isBrowser) {\n      return;\n    }\n\n    if (currentTheme === EDarkModes.SYSTEM) {\n      this.applyTheme(EDarkModes.LIGHT);\n    } else if (currentTheme === EDarkModes.LIGHT) {\n      this.applyTheme(EDarkModes.DARK);\n    } else {\n      this.applyTheme(EDarkModes.SYSTEM);\n    }\n  }\n\n  activateTheme(theme: DarkModeOptions): void {\n    if (!this.isBrowser) {\n      return;\n    }\n\n    this.applyTheme(theme);\n  }\n\n  getCurrentTheme(): DarkModeOptions {\n    return this.themeSignal();\n  }\n\n  private applyTheme(theme: DarkModeOptions): void {\n    if (!this.isBrowser) {\n      return;\n    }\n\n    localStorage.setItem(ZardDarkMode.STORAGE_KEY, theme);\n    this.themeSignal.set(theme);\n    // whenever we apply theme call listener removal\n    this.handleSystemChanges(false);\n\n    this.darkModeQuery ??= this.getDarkModeQuery();\n    this.updateThemeMode(this.isDarkMode());\n    if (theme === EDarkModes.SYSTEM) {\n      this.handleSystemChanges(true);\n    }\n  }\n\n  private getStoredTheme(): DarkModeOptions | undefined {\n    if (!this.isBrowser) {\n      return undefined;\n    }\n\n    const value = localStorage.getItem(ZardDarkMode.STORAGE_KEY);\n    if (value === EDarkModes.LIGHT || value === EDarkModes.DARK || value === EDarkModes.SYSTEM) {\n      return value;\n    }\n    return undefined;\n  }\n\n  private getThemeMode(isDarkMode: boolean): EDarkModes.LIGHT | EDarkModes.DARK {\n    return isDarkMode ? EDarkModes.DARK : EDarkModes.LIGHT;\n  }\n\n  private updateThemeMode(isDarkMode: boolean): void {\n    const themeMode = this.getThemeMode(isDarkMode);\n    const html = this.document.documentElement;\n    html.classList.toggle('dark', isDarkMode);\n    html.setAttribute('data-theme', themeMode);\n    html.style.colorScheme = themeMode;\n  }\n\n  private getDarkModeQuery(): MediaQueryList | undefined {\n    if (!this.isBrowser) {\n      return;\n    }\n    return this.document.defaultView?.matchMedia('(prefers-color-scheme: dark)');\n  }\n\n  private isDarkMode(): boolean {\n    if (!this.isBrowser) {\n      return false;\n    }\n\n    const isSystemDarkMode = this.darkModeQuery?.matches ?? false;\n    const stored = localStorage.getItem(ZardDarkMode.STORAGE_KEY);\n    return stored === EDarkModes.DARK || (stored === EDarkModes.SYSTEM && isSystemDarkMode);\n  }\n\n  private handleSystemChanges(addListener: boolean): void {\n    if (addListener) {\n      this.darkModeQuery?.addEventListener('change', this.handleThemeChange);\n    } else {\n      this.darkModeQuery?.removeEventListener('change', this.handleThemeChange);\n    }\n  }\n}\n"
    },
    {
      "name": "provider/providezard.ts",
      "content": "import { inject, makeEnvironmentProviders, provideAppInitializer, type EnvironmentProviders } from '@angular/core';\nimport { EVENT_MANAGER_PLUGINS } from '@angular/platform-browser';\n\nimport { ZardDebounceEventManagerPlugin } from './event-manager-plugins/zard-debounce-event-manager-plugin';\nimport { ZardEventManagerPlugin } from './event-manager-plugins/zard-event-manager-plugin';\nimport { ZardDarkMode } from './services/dark-mode';\n\nexport function provideZard(): EnvironmentProviders {\n  const darkMode = provideAppInitializer(() => inject(ZardDarkMode).init());\n\n  const eventManagerPlugins = [\n    {\n      provide: EVENT_MANAGER_PLUGINS,\n      useClass: ZardEventManagerPlugin,\n      multi: true,\n    },\n    {\n      provide: EVENT_MANAGER_PLUGINS,\n      useClass: ZardDebounceEventManagerPlugin,\n      multi: true,\n    },\n  ];\n\n  return makeEnvironmentProviders([darkMode, ...eventManagerPlugins]);\n}\n"
    }
  ]
}
