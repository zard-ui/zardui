{
  "name": "tree",
  "type": "registry:component",
  "files": [
    {
      "name": "tree.component.ts",
      "content": "import { CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport } from '@angular/cdk/scrolling';\nimport {\n  booleanAttribute,\n  ChangeDetectionStrategy,\n  Component,\n  computed,\n  contentChild,\n  effect,\n  ElementRef,\n  inject,\n  input,\n  numberAttribute,\n  output,\n  type TemplateRef,\n  ViewEncapsulation,\n} from '@angular/core';\n\nimport type { ClassValue } from 'clsx';\n\nimport { mergeClasses } from '@/shared/utils/merge-classes';\n\nimport { ZardTreeNodeComponent } from './tree-node.component';\nimport { ZardTreeService } from './tree.service';\nimport type { FlatTreeNode, TreeNode, TreeNodeTemplateContext } from './tree.types';\nimport { treeVariants } from './tree.variants';\n\n@Component({\n  selector: 'z-tree',\n  imports: [ZardTreeNodeComponent, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf],\n  template: `\n    @if (zVirtualScroll()) {\n      <cdk-virtual-scroll-viewport [itemSize]=\"zVirtualItemSize()\" class=\"h-full w-full\">\n        <z-tree-node\n          *cdkVirtualFor=\"let flatNode of flattenedNodes(); trackBy: trackByKey\"\n          [node]=\"flatNode.node\"\n          [level]=\"flatNode.level\"\n          [flat]=\"true\"\n          [selectable]=\"zSelectable()\"\n          [checkable]=\"zCheckable()\"\n          [nodeTemplate]=\"customNodeTemplate() ?? null\"\n          role=\"treeitem\"\n          [attr.aria-expanded]=\"flatNode.expandable ? treeService.isExpanded(flatNode.node.key) : null\"\n          [attr.aria-level]=\"flatNode.level + 1\"\n          [attr.aria-selected]=\"zSelectable() ? treeService.isSelected(flatNode.node.key) : null\"\n          [attr.aria-disabled]=\"flatNode.node.disabled || null\"\n          [attr.data-key]=\"flatNode.node.key\"\n        />\n      </cdk-virtual-scroll-viewport>\n    } @else {\n      @for (node of zData(); track node.key; let i = $index) {\n        <z-tree-node\n          [node]=\"node\"\n          [level]=\"0\"\n          [selectable]=\"zSelectable()\"\n          [checkable]=\"zCheckable()\"\n          [nodeTemplate]=\"customNodeTemplate() ?? null\"\n          role=\"treeitem\"\n          [attr.aria-expanded]=\"node.children?.length ? treeService.isExpanded(node.key) : null\"\n          [attr.aria-level]=\"1\"\n          [attr.aria-setsize]=\"zData().length\"\n          [attr.aria-posinset]=\"i + 1\"\n          [attr.aria-selected]=\"zSelectable() ? treeService.isSelected(node.key) : null\"\n          [attr.aria-disabled]=\"node.disabled || null\"\n          [attr.data-key]=\"node.key\"\n        />\n      }\n    }\n  `,\n  providers: [ZardTreeService],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  host: {\n    role: 'tree',\n    '[class]': 'classes()',\n    '(keydown)': 'onKeydown($event)',\n  },\n  exportAs: 'zTree',\n})\nexport class ZardTreeComponent<T = any> {\n  readonly treeService = inject(ZardTreeService<T>);\n  private readonly elementRef = inject(ElementRef);\n\n  readonly class = input<ClassValue>('');\n  readonly zData = input<TreeNode<T>[]>([]);\n  readonly zSelectable = input(false, { transform: booleanAttribute });\n  readonly zCheckable = input(false, { transform: booleanAttribute });\n  readonly zExpandAll = input(false, { transform: booleanAttribute });\n  readonly zVirtualScroll = input(false, { transform: booleanAttribute });\n  readonly zVirtualItemSize = input(32, { transform: numberAttribute });\n\n  readonly zNodeClick = output<TreeNode<T>>();\n  readonly zNodeExpand = output<TreeNode<T>>();\n  readonly zNodeCollapse = output<TreeNode<T>>();\n  readonly zSelectionChange = output<TreeNode<T>[]>();\n  readonly zCheckChange = output<TreeNode<T>[]>();\n\n  readonly customNodeTemplate = contentChild<TemplateRef<TreeNodeTemplateContext<T>>>('nodeTemplate');\n\n  protected readonly classes = computed(() => mergeClasses(treeVariants(), this.class()));\n\n  protected readonly flattenedNodes = computed(() => this.treeService.flattenedNodes());\n\n  private focusedIndex = 0;\n\n  constructor() {\n    // Sync data to service\n    effect(() => {\n      this.treeService.setData(this.zData());\n    });\n\n    // Expand all on init if requested\n    effect(() => {\n      if (this.zExpandAll()) {\n        this.treeService.expandAll();\n      }\n    });\n\n    // Emit selection changes\n    effect(() => {\n      const keys = this.treeService.selectedKeys();\n      if (keys.size > 0) {\n        this.zSelectionChange.emit(this.treeService.getSelectedNodes());\n      }\n    });\n\n    // Emit check changes\n    effect(() => {\n      const keys = this.treeService.checkedKeys();\n      if (keys.size > 0) {\n        this.zCheckChange.emit(this.treeService.getCheckedNodes());\n      }\n    });\n  }\n\n  trackByKey(_index: number, item: FlatTreeNode<T>): string {\n    return item.node.key;\n  }\n\n  onKeydown(event: KeyboardEvent) {\n    const nodes = this.treeService.flattenedNodes();\n    if (!nodes.length) {\n      return;\n    }\n\n    switch (event.key) {\n      case 'ArrowDown':\n        event.preventDefault();\n        this.moveFocus(Math.min(this.focusedIndex + 1, nodes.length - 1));\n        break;\n      case 'ArrowUp':\n        event.preventDefault();\n        this.moveFocus(Math.max(this.focusedIndex - 1, 0));\n        break;\n      case 'ArrowRight':\n        event.preventDefault();\n        this.expandFocusedNode();\n        break;\n      case 'ArrowLeft':\n        event.preventDefault();\n        this.collapseFocusedNode();\n        break;\n      case 'Home':\n        event.preventDefault();\n        this.moveFocus(0);\n        break;\n      case 'End':\n        event.preventDefault();\n        this.moveFocus(nodes.length - 1);\n        break;\n      case 'Enter':\n        event.preventDefault();\n        this.activateFocusedNode();\n        break;\n      case ' ':\n        event.preventDefault();\n        this.checkFocusedNode();\n        break;\n    }\n  }\n\n  // --- Keyboard helpers ---\n\n  private getFocusedNode(): FlatTreeNode<T> | undefined {\n    return this.treeService.flattenedNodes()[this.focusedIndex];\n  }\n\n  private moveFocus(index: number) {\n    this.focusedIndex = index;\n    const node = this.getFocusedNode();\n    if (node) {\n      this.focusDomNode(node.node.key);\n    }\n  }\n\n  private expandFocusedNode() {\n    const current = this.getFocusedNode();\n    if (current?.expandable && !this.treeService.isExpanded(current.node.key)) {\n      this.treeService.expand(current.node.key);\n      this.zNodeExpand.emit(current.node);\n    }\n  }\n\n  private collapseFocusedNode() {\n    const current = this.getFocusedNode();\n    if (current && this.treeService.isExpanded(current.node.key)) {\n      this.treeService.collapse(current.node.key);\n      this.zNodeCollapse.emit(current.node);\n    }\n  }\n\n  private activateFocusedNode() {\n    const current = this.getFocusedNode();\n    if (current && !current.node.disabled) {\n      this.zNodeClick.emit(current.node);\n      if (this.zSelectable()) {\n        this.treeService.select(current.node.key, 'single');\n      }\n    }\n  }\n\n  private checkFocusedNode() {\n    const current = this.getFocusedNode();\n    if (current && !current.node.disabled && this.zCheckable()) {\n      this.treeService.toggleCheck(current.node);\n    }\n  }\n\n  private focusDomNode(key: string) {\n    const el = (this.elementRef.nativeElement as HTMLElement).querySelector<HTMLElement>(`[data-key=\"${key}\"]`);\n    el?.focus();\n  }\n}\n"
    },
    {
      "name": "tree-node.component.ts",
      "content": "import { NgTemplateOutlet } from '@angular/common';\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  computed,\n  inject,\n  input,\n  type TemplateRef,\n  ViewEncapsulation,\n} from '@angular/core';\nimport { FormsModule } from '@angular/forms';\n\nimport type { ClassValue } from 'clsx';\n\nimport { ZardCheckboxComponent } from '@/shared/components/checkbox/checkbox.component';\nimport { ZardIconComponent } from '@/shared/components/icon';\nimport { mergeClasses } from '@/shared/utils/merge-classes';\n\nimport { ZardTreeService } from './tree.service';\nimport type { TreeNode, TreeNodeTemplateContext } from './tree.types';\nimport {\n  treeNodeChildrenVariants,\n  treeNodeContentVariants,\n  treeNodeToggleVariants,\n  treeNodeVariants,\n} from './tree.variants';\n\n@Component({\n  selector: 'z-tree-node',\n  imports: [NgTemplateOutlet, FormsModule, ZardIconComponent, ZardCheckboxComponent],\n  template: `\n    <div\n      class=\"flex items-center\"\n      [style.padding-left.px]=\"level() * 24\"\n      [attr.data-state]=\"isExpanded() ? 'open' : 'closed'\"\n    >\n      <!-- Toggle -->\n      @if (node().children?.length && !node().leaf) {\n        <button\n          type=\"button\"\n          [class]=\"toggleClasses()\"\n          [attr.aria-label]=\"isExpanded() ? 'Collapse ' + node().label : 'Expand ' + node().label\"\n          [attr.tabindex]=\"-1\"\n          (click)=\"onToggle($event)\"\n        >\n          <z-icon zType=\"chevron-right\" class=\"size-4\" />\n        </button>\n      } @else {\n        <span class=\"inline-flex h-6 w-6 shrink-0\"></span>\n      }\n\n      <!-- Checkbox -->\n      @if (checkable()) {\n        <z-checkbox\n          class=\"mr-1\"\n          [ngModel]=\"checkState() === 'checked'\"\n          [zDisabled]=\"node().disabled ?? false\"\n          [attr.aria-checked]=\"checkState() === 'indeterminate' ? 'mixed' : checkState() === 'checked'\"\n          (checkChange)=\"onCheckChange()\"\n        />\n      }\n\n      <!-- Content -->\n      <div\n        [class]=\"contentClasses()\"\n        [attr.data-selected]=\"isSelected() || null\"\n        [attr.tabindex]=\"node().disabled ? -1 : 0\"\n        role=\"treeitem\"\n        [attr.aria-selected]=\"isSelected()\"\n        (click)=\"onContentClick()\"\n        (keydown.enter)=\"onContentClick()\"\n      >\n        @if (nodeTemplate(); as tmpl) {\n          <ng-container [ngTemplateOutlet]=\"tmpl\" [ngTemplateOutletContext]=\"{ $implicit: node(), level: level() }\" />\n        } @else {\n          @if (node().icon) {\n            <z-icon [zType]=\"$any(node().icon)\" class=\"mr-1.5 size-4 shrink-0\" />\n          }\n          <span class=\"truncate\">{{ node().label }}</span>\n        }\n      </div>\n    </div>\n\n    <!-- Children (animated collapse) â€” skip in flat/virtual-scroll mode -->\n    @if (!flat() && node().children?.length && !node().leaf) {\n      <div role=\"group\" [class]=\"childrenClasses()\">\n        <div class=\"overflow-hidden\">\n          @for (child of node().children; track child.key; let i = $index) {\n            <z-tree-node\n              [node]=\"child\"\n              [level]=\"level() + 1\"\n              [selectable]=\"selectable()\"\n              [checkable]=\"checkable()\"\n              [nodeTemplate]=\"nodeTemplate()\"\n              role=\"treeitem\"\n              [attr.aria-expanded]=\"child.children?.length ? treeService.isExpanded(child.key) : null\"\n              [attr.aria-level]=\"level() + 2\"\n              [attr.aria-setsize]=\"node().children!.length\"\n              [attr.aria-posinset]=\"i + 1\"\n              [attr.aria-selected]=\"selectable() ? treeService.isSelected(child.key) : null\"\n              [attr.aria-disabled]=\"child.disabled || null\"\n              [attr.data-key]=\"child.key\"\n            />\n          }\n        </div>\n      </div>\n    }\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  host: {\n    '[class]': 'hostClasses()',\n    '[attr.data-key]': 'node().key',\n  },\n  exportAs: 'zTreeNode',\n})\nexport class ZardTreeNodeComponent<T = any> {\n  readonly treeService = inject(ZardTreeService);\n\n  readonly node = input.required<TreeNode<T>>();\n  readonly level = input<number>(0);\n  readonly selectable = input<boolean>(false);\n  readonly checkable = input<boolean>(false);\n  readonly flat = input<boolean>(false);\n  readonly nodeTemplate = input<TemplateRef<TreeNodeTemplateContext<T>> | null>(null);\n  readonly class = input<ClassValue>('');\n\n  readonly isExpanded = computed(() => this.treeService.isExpanded(this.node().key));\n\n  readonly isSelected = computed(() => this.treeService.isSelected(this.node().key));\n\n  readonly checkState = computed(() => this.treeService.getCheckState(this.node().key));\n\n  protected readonly hostClasses = computed(() =>\n    mergeClasses(treeNodeVariants({ disabled: this.node().disabled ?? false }), this.class()),\n  );\n\n  protected readonly toggleClasses = computed(() =>\n    mergeClasses(treeNodeToggleVariants({ isExpanded: this.isExpanded() })),\n  );\n\n  protected readonly contentClasses = computed(() =>\n    mergeClasses(treeNodeContentVariants({ isSelected: this.isSelected() })),\n  );\n\n  protected readonly childrenClasses = computed(() =>\n    mergeClasses(treeNodeChildrenVariants({ isExpanded: this.isExpanded() })),\n  );\n\n  onToggle(event: Event) {\n    event.stopPropagation();\n    this.treeService.toggle(this.node().key);\n  }\n\n  onContentClick() {\n    if (this.node().disabled) {\n      return;\n    }\n    if (this.selectable()) {\n      this.treeService.select(this.node().key, 'single');\n    }\n  }\n\n  onCheckChange() {\n    if (this.node().disabled) {\n      return;\n    }\n    this.treeService.toggleCheck(this.node());\n  }\n}\n"
    },
    {
      "name": "tree-node-toggle.directive.ts",
      "content": "import { computed, Directive, inject, input } from '@angular/core';\n\nimport { mergeClasses } from '@/shared/utils/merge-classes';\n\nimport { ZardTreeService } from './tree.service';\nimport { treeNodeToggleVariants } from './tree.variants';\n\n@Directive({\n  selector: '[z-tree-node-toggle]',\n  host: {\n    role: 'button',\n    '[class]': 'classes()',\n    '[attr.aria-label]': 'isExpanded() ? \"Collapse\" : \"Expand\"',\n    '[attr.tabindex]': '-1',\n    '(click)': 'onClick($event)',\n  },\n  exportAs: 'zTreeNodeToggle',\n})\nexport class ZardTreeNodeToggleDirective {\n  private readonly treeService = inject(ZardTreeService);\n\n  readonly nodeKey = input.required<string>({ alias: 'z-tree-node-toggle' });\n\n  readonly isExpanded = computed(() => this.treeService.isExpanded(this.nodeKey()));\n\n  protected readonly classes = computed(() => mergeClasses(treeNodeToggleVariants({ isExpanded: this.isExpanded() })));\n\n  onClick(event: Event) {\n    event.stopPropagation();\n    this.treeService.toggle(this.nodeKey());\n  }\n}\n"
    },
    {
      "name": "tree-node-content.component.ts",
      "content": "import { ChangeDetectionStrategy, Component, computed, inject, input, ViewEncapsulation } from '@angular/core';\n\nimport type { ClassValue } from 'clsx';\n\nimport { mergeClasses } from '@/shared/utils/merge-classes';\n\nimport { ZardTreeService } from './tree.service';\nimport { treeNodeContentVariants } from './tree.variants';\n\n@Component({\n  selector: 'z-tree-node-content',\n  template: `\n    <ng-content />\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  host: {\n    '[class]': 'classes()',\n  },\n  exportAs: 'zTreeNodeContent',\n})\nexport class ZardTreeNodeContentComponent {\n  private readonly treeService = inject(ZardTreeService);\n\n  readonly class = input<ClassValue>('');\n  readonly nodeKey = input.required<string>();\n\n  readonly isSelected = computed(() => this.treeService.isSelected(this.nodeKey()));\n\n  protected readonly classes = computed(() =>\n    mergeClasses(treeNodeContentVariants({ isSelected: this.isSelected() }), this.class()),\n  );\n}\n"
    },
    {
      "name": "tree.service.ts",
      "content": "import { computed, Injectable, signal } from '@angular/core';\n\nimport type { FlatTreeNode, TreeCheckState, TreeNode } from './tree.types';\n\n@Injectable()\nexport class ZardTreeService<T = any> {\n  readonly expandedKeys = signal<Set<string>>(new Set());\n  readonly selectedKeys = signal<Set<string>>(new Set());\n  readonly checkedKeys = signal<Set<string>>(new Set());\n  readonly indeterminateKeys = signal<Set<string>>(new Set());\n\n  private readonly dataSignal = signal<TreeNode<T>[]>([]);\n\n  readonly flattenedNodes = computed(() => {\n    const result: FlatTreeNode<T>[] = [];\n    let index = 0;\n    const flatten = (nodes: TreeNode<T>[], level: number) => {\n      for (const node of nodes) {\n        const expandable = !node.leaf && !!node.children?.length;\n        result.push({ node, level, expandable, index: index++ });\n        if (expandable && this.expandedKeys().has(node.key)) {\n          flatten(node.children!, level + 1);\n        }\n      }\n    };\n    flatten(this.dataSignal(), 0);\n    return result;\n  });\n\n  setData(data: TreeNode<T>[]) {\n    this.dataSignal.set(data);\n  }\n\n  // --- Expand / Collapse ---\n\n  isExpanded(key: string): boolean {\n    return this.expandedKeys().has(key);\n  }\n\n  toggle(key: string) {\n    if (this.isExpanded(key)) {\n      this.collapse(key);\n    } else {\n      this.expand(key);\n    }\n  }\n\n  expand(key: string) {\n    this.expandedKeys.update(keys => {\n      const next = new Set(keys);\n      next.add(key);\n      return next;\n    });\n  }\n\n  collapse(key: string) {\n    this.expandedKeys.update(keys => {\n      const next = new Set(keys);\n      next.delete(key);\n      return next;\n    });\n  }\n\n  expandAll() {\n    const allKeys = new Set<string>();\n    const collect = (nodes: TreeNode<T>[]) => {\n      for (const node of nodes) {\n        if (!node.leaf && node.children?.length) {\n          allKeys.add(node.key);\n          collect(node.children);\n        }\n      }\n    };\n    collect(this.dataSignal());\n    this.expandedKeys.set(allKeys);\n  }\n\n  collapseAll() {\n    this.expandedKeys.set(new Set());\n  }\n\n  // --- Selection ---\n\n  isSelected(key: string): boolean {\n    return this.selectedKeys().has(key);\n  }\n\n  select(key: string, mode: 'single' | 'multiple') {\n    if (mode === 'single') {\n      this.selectedKeys.set(new Set([key]));\n    } else {\n      this.selectedKeys.update(keys => {\n        const next = new Set(keys);\n        if (next.has(key)) {\n          next.delete(key);\n        } else {\n          next.add(key);\n        }\n        return next;\n      });\n    }\n  }\n\n  deselect(key: string) {\n    this.selectedKeys.update(keys => {\n      const next = new Set(keys);\n      next.delete(key);\n      return next;\n    });\n  }\n\n  getSelectedNodes(): TreeNode<T>[] {\n    const selected: TreeNode<T>[] = [];\n    const collect = (nodes: TreeNode<T>[]) => {\n      for (const node of nodes) {\n        if (this.selectedKeys().has(node.key)) {\n          selected.push(node);\n        }\n        if (node.children?.length) {\n          collect(node.children);\n        }\n      }\n    };\n    collect(this.dataSignal());\n    return selected;\n  }\n\n  // --- Checkbox with propagation ---\n\n  getCheckState(key: string): TreeCheckState {\n    if (this.checkedKeys().has(key)) {\n      return 'checked';\n    }\n    if (this.indeterminateKeys().has(key)) {\n      return 'indeterminate';\n    }\n    return 'unchecked';\n  }\n\n  toggleCheck(node: TreeNode<T>) {\n    const isChecked = this.checkedKeys().has(node.key);\n    if (isChecked) {\n      this.uncheckNode(node);\n    } else {\n      this.checkNode(node);\n    }\n    this.updateAncestors(this.dataSignal());\n  }\n\n  private checkNode(node: TreeNode<T>) {\n    this.checkedKeys.update(keys => {\n      const next = new Set(keys);\n      next.add(node.key);\n      return next;\n    });\n    this.indeterminateKeys.update(keys => {\n      const next = new Set(keys);\n      next.delete(node.key);\n      return next;\n    });\n    if (node.children?.length) {\n      for (const child of node.children) {\n        if (!child.disabled) {\n          this.checkNode(child);\n        }\n      }\n    }\n  }\n\n  private uncheckNode(node: TreeNode<T>) {\n    this.checkedKeys.update(keys => {\n      const next = new Set(keys);\n      next.delete(node.key);\n      return next;\n    });\n    this.indeterminateKeys.update(keys => {\n      const next = new Set(keys);\n      next.delete(node.key);\n      return next;\n    });\n    if (node.children?.length) {\n      for (const child of node.children) {\n        if (!child.disabled) {\n          this.uncheckNode(child);\n        }\n      }\n    }\n  }\n\n  private updateAncestors(nodes: TreeNode<T>[]) {\n    const checked = this.checkedKeys();\n    const nextIndeterminate = new Set<string>();\n\n    const computeState = (node: TreeNode<T>): 'checked' | 'unchecked' | 'indeterminate' => {\n      if (!node.children?.length) {\n        return checked.has(node.key) ? 'checked' : 'unchecked';\n      }\n\n      const childStates = node.children.filter(c => !c.disabled).map(c => computeState(c));\n\n      const allChecked = childStates.length > 0 && childStates.every(s => s === 'checked');\n      const someChecked = childStates.some(s => s === 'checked' || s === 'indeterminate');\n\n      if (allChecked) {\n        this.checkedKeys.update(keys => {\n          const next = new Set(keys);\n          next.add(node.key);\n          return next;\n        });\n        return 'checked';\n      } else if (someChecked) {\n        this.checkedKeys.update(keys => {\n          const next = new Set(keys);\n          next.delete(node.key);\n          return next;\n        });\n        nextIndeterminate.add(node.key);\n        return 'indeterminate';\n      } else {\n        this.checkedKeys.update(keys => {\n          const next = new Set(keys);\n          next.delete(node.key);\n          return next;\n        });\n        return 'unchecked';\n      }\n    };\n\n    for (const node of nodes) {\n      computeState(node);\n    }\n\n    this.indeterminateKeys.set(nextIndeterminate);\n  }\n\n  getCheckedNodes(): TreeNode<T>[] {\n    const result: TreeNode<T>[] = [];\n    const collect = (nodes: TreeNode<T>[]) => {\n      for (const node of nodes) {\n        if (this.checkedKeys().has(node.key)) {\n          result.push(node);\n        }\n        if (node.children?.length) {\n          collect(node.children);\n        }\n      }\n    };\n    collect(this.dataSignal());\n    return result;\n  }\n\n  // --- Helpers ---\n\n  findNode(key: string, nodes?: TreeNode<T>[]): TreeNode<T> | null {\n    for (const node of nodes ?? this.dataSignal()) {\n      if (node.key === key) {\n        return node;\n      }\n      if (node.children?.length) {\n        const found = this.findNode(key, node.children);\n        if (found) {\n          return found;\n        }\n      }\n    }\n    return null;\n  }\n}\n"
    },
    {
      "name": "tree.types.ts",
      "content": "export interface TreeNode<T = any> {\n  key: string;\n  label: string;\n  data?: T;\n  icon?: string;\n  children?: TreeNode<T>[];\n  expanded?: boolean;\n  selected?: boolean;\n  checked?: boolean;\n  disabled?: boolean;\n  leaf?: boolean;\n}\n\nexport interface TreeNodeTemplateContext<T = unknown> {\n  $implicit: TreeNode<T>;\n  level: number;\n}\n\nexport type TreeCheckState = 'checked' | 'unchecked' | 'indeterminate';\n\nexport interface FlatTreeNode<T = any> {\n  node: TreeNode<T>;\n  level: number;\n  expandable: boolean;\n  index: number;\n}\n"
    },
    {
      "name": "tree.variants.ts",
      "content": "import { cva, type VariantProps } from 'class-variance-authority';\n\nexport const treeVariants = cva('flex flex-col text-sm', {\n  variants: {},\n  defaultVariants: {},\n});\n\nexport const treeNodeVariants = cva('flex flex-col', {\n  variants: {\n    disabled: {\n      true: 'opacity-50 pointer-events-none',\n      false: '',\n    },\n  },\n  defaultVariants: {\n    disabled: false,\n  },\n});\n\nexport const treeNodeToggleVariants = cva(\n  'inline-flex h-6 w-6 shrink-0 items-center justify-center rounded-sm transition-transform duration-200 hover:bg-accent focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring',\n  {\n    variants: {\n      isExpanded: {\n        true: 'rotate-90',\n        false: 'rotate-0',\n      },\n    },\n    defaultVariants: {\n      isExpanded: false,\n    },\n  },\n);\n\nexport const treeNodeContentVariants = cva(\n  'flex flex-1 items-center gap-2 rounded-sm px-2 py-1.5 text-sm cursor-pointer select-none transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring',\n  {\n    variants: {\n      isSelected: {\n        true: 'bg-accent text-accent-foreground',\n        false: '',\n      },\n    },\n    defaultVariants: {\n      isSelected: false,\n    },\n  },\n);\n\nexport const treeNodeChildrenVariants = cva('grid transition-all duration-200 ease-in-out', {\n  variants: {\n    isExpanded: {\n      true: 'grid-rows-[1fr]',\n      false: 'grid-rows-[0fr]',\n    },\n  },\n  defaultVariants: {\n    isExpanded: false,\n  },\n});\n\nexport type ZardTreeVariants = VariantProps<typeof treeVariants>;\nexport type ZardTreeNodeVariants = VariantProps<typeof treeNodeVariants>;\nexport type ZardTreeNodeToggleVariants = VariantProps<typeof treeNodeToggleVariants>;\nexport type ZardTreeNodeContentVariants = VariantProps<typeof treeNodeContentVariants>;\nexport type ZardTreeNodeChildrenVariants = VariantProps<typeof treeNodeChildrenVariants>;\n"
    },
    {
      "name": "tree.imports.ts",
      "content": "import { ZardTreeNodeContentComponent } from '@/shared/components/tree/tree-node-content.component';\nimport { ZardTreeNodeToggleDirective } from '@/shared/components/tree/tree-node-toggle.directive';\nimport { ZardTreeNodeComponent } from '@/shared/components/tree/tree-node.component';\nimport { ZardTreeComponent } from '@/shared/components/tree/tree.component';\n\nexport const ZardTreeImports = [\n  ZardTreeComponent,\n  ZardTreeNodeComponent,\n  ZardTreeNodeToggleDirective,\n  ZardTreeNodeContentComponent,\n] as const;\n"
    },
    {
      "name": "index.ts",
      "content": "export * from '@/shared/components/tree/tree.component';\nexport * from '@/shared/components/tree/tree-node.component';\nexport * from '@/shared/components/tree/tree-node-toggle.directive';\nexport * from '@/shared/components/tree/tree-node-content.component';\nexport * from '@/shared/components/tree/tree.service';\nexport * from '@/shared/components/tree/tree.types';\nexport * from '@/shared/components/tree/tree.variants';\nexport * from '@/shared/components/tree/tree.imports';\n"
    }
  ],
  "registryDependencies": [
    "icon",
    "checkbox"
  ]
}
