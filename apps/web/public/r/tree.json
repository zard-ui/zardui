{
  "name": "tree",
  "type": "registry:component",
  "files": [
    {
      "name": "tree.component.ts",
      "content": "import { CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport } from '@angular/cdk/scrolling';\nimport {\n  booleanAttribute,\n  ChangeDetectionStrategy,\n  Component,\n  computed,\n  contentChild,\n  effect,\n  ElementRef,\n  inject,\n  input,\n  numberAttribute,\n  output,\n  type TemplateRef,\n  ViewEncapsulation,\n} from '@angular/core';\n\nimport type { ClassValue } from 'clsx';\n\nimport { mergeClasses } from '@/shared/utils/merge-classes';\n\nimport { ZardTreeNodeComponent } from './tree-node.component';\nimport { ZardTreeService } from './tree.service';\nimport type { FlatTreeNode, TreeNode, TreeNodeTemplateContext } from './tree.types';\nimport { treeVariants } from './tree.variants';\n\n@Component({\n  selector: 'z-tree',\n  imports: [ZardTreeNodeComponent, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf],\n  template: `\n    @if (zVirtualScroll()) {\n      <cdk-virtual-scroll-viewport [itemSize]=\"zVirtualItemSize()\" class=\"size-full\">\n        <z-tree-node\n          *cdkVirtualFor=\"let flatNode of flattenedNodes(); trackBy: trackByKey\"\n          [node]=\"flatNode.node\"\n          [level]=\"flatNode.level\"\n          [flat]=\"true\"\n          [selectable]=\"zSelectable()\"\n          [checkable]=\"zCheckable()\"\n          [nodeTemplate]=\"customNodeTemplate() ?? null\"\n          role=\"treeitem\"\n          [attr.aria-expanded]=\"flatNode.expandable ? treeService.isExpanded(flatNode.node.key) : null\"\n          [attr.aria-level]=\"flatNode.level + 1\"\n          [attr.aria-selected]=\"zSelectable() ? treeService.isSelected(flatNode.node.key) : null\"\n          [attr.aria-disabled]=\"flatNode.node.disabled || null\"\n          [attr.data-key]=\"flatNode.node.key\"\n        />\n      </cdk-virtual-scroll-viewport>\n    } @else {\n      @for (node of zData(); track node.key; let i = $index) {\n        <z-tree-node\n          [node]=\"node\"\n          [level]=\"0\"\n          [selectable]=\"zSelectable()\"\n          [checkable]=\"zCheckable()\"\n          [nodeTemplate]=\"customNodeTemplate() ?? null\"\n          role=\"treeitem\"\n          [attr.aria-expanded]=\"node.children?.length ? treeService.isExpanded(node.key) : null\"\n          [attr.aria-level]=\"1\"\n          [attr.aria-setsize]=\"zData().length\"\n          [attr.aria-posinset]=\"i + 1\"\n          [attr.aria-selected]=\"zSelectable() ? treeService.isSelected(node.key) : null\"\n          [attr.aria-disabled]=\"node.disabled || null\"\n          [attr.data-key]=\"node.key\"\n        />\n      }\n    }\n  `,\n  providers: [ZardTreeService],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  host: {\n    role: 'tree',\n    '[class]': 'classes()',\n    '(keydown)': 'onKeydown($event)',\n  },\n  exportAs: 'zTree',\n})\nexport class ZardTreeComponent<T = any> {\n  readonly treeService = inject(ZardTreeService<T>);\n  private readonly elementRef = inject(ElementRef);\n\n  readonly class = input<ClassValue>('');\n  readonly zData = input<TreeNode<T>[]>([]);\n  readonly zSelectable = input(false, { transform: booleanAttribute });\n  readonly zCheckable = input(false, { transform: booleanAttribute });\n  readonly zExpandAll = input(false, { transform: booleanAttribute });\n  readonly zVirtualScroll = input(false, { transform: booleanAttribute });\n  readonly zVirtualItemSize = input(32, { transform: numberAttribute });\n\n  readonly zNodeClick = output<TreeNode<T>>();\n  readonly zNodeExpand = output<TreeNode<T>>();\n  readonly zNodeCollapse = output<TreeNode<T>>();\n  readonly zSelectionChange = output<TreeNode<T>[]>();\n  readonly zCheckChange = output<TreeNode<T>[]>();\n\n  readonly customNodeTemplate = contentChild<TemplateRef<TreeNodeTemplateContext<T>>>('nodeTemplate');\n\n  protected readonly classes = computed(() => mergeClasses(treeVariants(), this.class()));\n\n  protected readonly flattenedNodes = computed(() => this.treeService.flattenedNodes());\n\n  private focusedIndex = 0;\n\n  constructor() {\n    // Sync data to service\n    effect(() => {\n      this.treeService.setData(this.zData());\n    });\n\n    // Expand all on init if requested\n    effect(() => {\n      if (this.zExpandAll()) {\n        this.treeService.expandAll();\n      }\n    });\n\n    // Emit node click from tree-node interactions\n    effect(() => {\n      const clicked = this.treeService.clickedNode();\n      if (clicked) {\n        this.zNodeClick.emit(clicked.node);\n      }\n    });\n\n    // Emit selection changes\n    effect(() => {\n      const keys = this.treeService.selectedKeys();\n      if (keys.size > 0) {\n        this.zSelectionChange.emit(this.treeService.getSelectedNodes());\n      }\n    });\n\n    // Emit check changes\n    effect(() => {\n      const keys = this.treeService.checkedKeys();\n      if (keys.size > 0) {\n        this.zCheckChange.emit(this.treeService.getCheckedNodes());\n      }\n    });\n  }\n\n  trackByKey(_index: number, item: FlatTreeNode<T>): string {\n    return item.node.key;\n  }\n\n  onKeydown(event: KeyboardEvent) {\n    const nodes = this.treeService.flattenedNodes();\n    if (!nodes.length) {\n      return;\n    }\n\n    switch (event.key) {\n      case 'ArrowDown':\n        event.preventDefault();\n        this.moveFocus(Math.min(this.focusedIndex + 1, nodes.length - 1));\n        break;\n      case 'ArrowUp':\n        event.preventDefault();\n        this.moveFocus(Math.max(this.focusedIndex - 1, 0));\n        break;\n      case 'ArrowRight':\n        event.preventDefault();\n        this.expandFocusedNode();\n        break;\n      case 'ArrowLeft':\n        event.preventDefault();\n        this.collapseFocusedNode();\n        break;\n      case 'Home':\n        event.preventDefault();\n        this.moveFocus(0);\n        break;\n      case 'End':\n        event.preventDefault();\n        this.moveFocus(nodes.length - 1);\n        break;\n      case 'Enter':\n        event.preventDefault();\n        this.activateFocusedNode();\n        break;\n      case ' ':\n        event.preventDefault();\n        this.checkFocusedNode();\n        break;\n    }\n  }\n\n  // --- Keyboard helpers ---\n\n  private getFocusedNode(): FlatTreeNode<T> | undefined {\n    return this.treeService.flattenedNodes()[this.focusedIndex];\n  }\n\n  private moveFocus(index: number) {\n    this.focusedIndex = index;\n    const node = this.getFocusedNode();\n    if (node) {\n      this.focusDomNode(node.node.key);\n    }\n  }\n\n  private expandFocusedNode() {\n    const current = this.getFocusedNode();\n    if (current?.expandable && !this.treeService.isExpanded(current.node.key)) {\n      this.treeService.expand(current.node.key);\n      this.zNodeExpand.emit(current.node);\n    }\n  }\n\n  private collapseFocusedNode() {\n    const current = this.getFocusedNode();\n    if (current && this.treeService.isExpanded(current.node.key)) {\n      this.treeService.collapse(current.node.key);\n      this.zNodeCollapse.emit(current.node);\n    }\n  }\n\n  private activateFocusedNode() {\n    const current = this.getFocusedNode();\n    if (current && !current.node.disabled) {\n      this.treeService.notifyNodeClick(current.node);\n      if (this.zSelectable()) {\n        this.treeService.select(current.node.key, 'single');\n      }\n    }\n  }\n\n  private checkFocusedNode() {\n    const current = this.getFocusedNode();\n    if (current && !current.node.disabled && this.zCheckable()) {\n      this.treeService.toggleCheck(current.node);\n    }\n  }\n\n  private focusDomNode(key: string) {\n    const el = (this.elementRef.nativeElement as HTMLElement).querySelector<HTMLElement>(`[data-key=\"${key}\"]`);\n    el?.focus();\n  }\n}\n"
    },
    {
      "name": "tree-node.component.ts",
      "content": "import { NgTemplateOutlet } from '@angular/common';\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  computed,\n  inject,\n  input,\n  type TemplateRef,\n  ViewEncapsulation,\n} from '@angular/core';\nimport { FormsModule } from '@angular/forms';\n\nimport type { ClassValue } from 'clsx';\n\nimport { ZardCheckboxComponent } from '@/shared/components/checkbox/checkbox.component';\nimport { ZardIconComponent } from '@/shared/components/icon';\nimport { mergeClasses } from '@/shared/utils/merge-classes';\n\nimport { ZardTreeService } from './tree.service';\nimport type { TreeNode, TreeNodeTemplateContext } from './tree.types';\nimport {\n  treeNodeChildrenVariants,\n  treeNodeContentVariants,\n  treeNodeToggleVariants,\n  treeNodeVariants,\n} from './tree.variants';\n\n@Component({\n  selector: 'z-tree-node',\n  imports: [NgTemplateOutlet, FormsModule, ZardIconComponent, ZardCheckboxComponent],\n  template: `\n    <div\n      class=\"flex items-center\"\n      [style.padding-left.px]=\"level() * 24\"\n      [attr.data-state]=\"isExpanded() ? 'open' : 'closed'\"\n    >\n      <!-- Toggle -->\n      @if (node().children?.length && !node().leaf) {\n        <button\n          type=\"button\"\n          [class]=\"toggleClasses()\"\n          [attr.aria-label]=\"isExpanded() ? 'Collapse ' + node().label : 'Expand ' + node().label\"\n          [attr.tabindex]=\"-1\"\n          (click)=\"onToggle($event)\"\n        >\n          <z-icon zType=\"chevron-right\" class=\"size-4\" />\n        </button>\n      } @else {\n        <span class=\"inline-flex size-4 shrink-0\"></span>\n      }\n\n      <!-- Checkbox -->\n      @if (checkable()) {\n        <span class=\"mr-0.5 ml-1.5\">\n          <z-checkbox\n            [ngModel]=\"checkState() === 'checked'\"\n            [zDisabled]=\"node().disabled ?? false\"\n            [attr.aria-checked]=\"checkState() === 'indeterminate' ? 'mixed' : checkState() === 'checked'\"\n            (checkChange)=\"onCheckChange()\"\n          />\n        </span>\n      }\n\n      <!-- Content -->\n      <div\n        [class]=\"contentClasses()\"\n        [attr.data-selected]=\"isSelected() || null\"\n        [attr.tabindex]=\"node().disabled ? -1 : 0\"\n        role=\"treeitem\"\n        [attr.aria-selected]=\"isSelected()\"\n        (click)=\"onContentClick()\"\n        (keydown.enter.stop)=\"onContentClick()\"\n      >\n        @if (nodeTemplate(); as tmpl) {\n          <ng-container [ngTemplateOutlet]=\"tmpl\" [ngTemplateOutletContext]=\"{ $implicit: node(), level: level() }\" />\n        } @else {\n          @if (node().icon) {\n            <z-icon [zType]=\"$any(node().icon)\" class=\"size-4 shrink-0\" />\n          }\n          <span class=\"truncate\">{{ node().label }}</span>\n        }\n      </div>\n    </div>\n\n    <!-- Children (animated collapse) — skip in flat/virtual-scroll mode -->\n    @if (!flat() && node().children?.length && !node().leaf) {\n      <div role=\"group\" [class]=\"childrenClasses()\">\n        <div class=\"overflow-hidden\">\n          @for (child of node().children; track child.key; let i = $index) {\n            <z-tree-node\n              [node]=\"child\"\n              [level]=\"level() + 1\"\n              [selectable]=\"selectable()\"\n              [checkable]=\"checkable()\"\n              [nodeTemplate]=\"nodeTemplate()\"\n              role=\"treeitem\"\n              [attr.aria-expanded]=\"child.children?.length ? treeService.isExpanded(child.key) : null\"\n              [attr.aria-level]=\"level() + 2\"\n              [attr.aria-setsize]=\"node().children!.length\"\n              [attr.aria-posinset]=\"i + 1\"\n              [attr.aria-selected]=\"selectable() ? treeService.isSelected(child.key) : null\"\n              [attr.aria-disabled]=\"child.disabled || null\"\n              [attr.data-key]=\"child.key\"\n            />\n          }\n        </div>\n      </div>\n    }\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  host: {\n    '[class]': 'hostClasses()',\n    '[attr.data-key]': 'node().key',\n  },\n  exportAs: 'zTreeNode',\n})\nexport class ZardTreeNodeComponent<T = any> {\n  readonly treeService = inject(ZardTreeService);\n\n  readonly node = input.required<TreeNode<T>>();\n  readonly level = input<number>(0);\n  readonly selectable = input<boolean>(false);\n  readonly checkable = input<boolean>(false);\n  readonly flat = input<boolean>(false);\n  readonly nodeTemplate = input<TemplateRef<TreeNodeTemplateContext<T>> | null>(null);\n  readonly class = input<ClassValue>('');\n\n  readonly isExpanded = computed(() => this.treeService.isExpanded(this.node().key));\n\n  readonly isSelected = computed(() => this.treeService.isSelected(this.node().key));\n\n  readonly checkState = computed(() => this.treeService.getCheckState(this.node().key));\n\n  protected readonly hostClasses = computed(() =>\n    mergeClasses(treeNodeVariants({ disabled: this.node().disabled ?? false }), this.class()),\n  );\n\n  protected readonly toggleClasses = computed(() =>\n    mergeClasses(treeNodeToggleVariants({ isExpanded: this.isExpanded() })),\n  );\n\n  protected readonly contentClasses = computed(() =>\n    mergeClasses(treeNodeContentVariants({ isSelected: this.isSelected() })),\n  );\n\n  protected readonly childrenClasses = computed(() =>\n    mergeClasses(treeNodeChildrenVariants({ isExpanded: this.isExpanded() })),\n  );\n\n  onToggle(event: Event) {\n    event.stopPropagation();\n    this.treeService.toggle(this.node().key);\n  }\n\n  onContentClick() {\n    if (this.node().disabled) {\n      return;\n    }\n    this.treeService.notifyNodeClick(this.node());\n    if (this.selectable()) {\n      this.treeService.select(this.node().key, 'single');\n    }\n  }\n\n  onCheckChange() {\n    if (this.node().disabled) {\n      return;\n    }\n    this.treeService.toggleCheck(this.node());\n  }\n}\n"
    },
    {
      "name": "tree-node-toggle.directive.ts",
      "content": "import { computed, Directive, inject, input } from '@angular/core';\n\nimport { mergeClasses } from '@/shared/utils/merge-classes';\n\nimport { ZardTreeService } from './tree.service';\nimport { treeNodeToggleVariants } from './tree.variants';\n\n@Directive({\n  selector: '[z-tree-node-toggle]',\n  host: {\n    role: 'button',\n    '[class]': 'classes()',\n    '[attr.aria-label]': 'isExpanded() ? \"Collapse\" : \"Expand\"',\n    '[attr.tabindex]': '-1',\n    '(click)': 'onClick($event)',\n  },\n  exportAs: 'zTreeNodeToggle',\n})\nexport class ZardTreeNodeToggleDirective {\n  private readonly treeService = inject(ZardTreeService);\n\n  readonly nodeKey = input.required<string>({ alias: 'z-tree-node-toggle' });\n\n  readonly isExpanded = computed(() => this.treeService.isExpanded(this.nodeKey()));\n\n  protected readonly classes = computed(() => mergeClasses(treeNodeToggleVariants({ isExpanded: this.isExpanded() })));\n\n  onClick(event: Event) {\n    event.stopPropagation();\n    this.treeService.toggle(this.nodeKey());\n  }\n}\n"
    },
    {
      "name": "tree-node-content.component.ts",
      "content": "import { ChangeDetectionStrategy, Component, computed, inject, input, ViewEncapsulation } from '@angular/core';\n\nimport type { ClassValue } from 'clsx';\n\nimport { mergeClasses } from '@/shared/utils/merge-classes';\n\nimport { ZardTreeService } from './tree.service';\nimport { treeNodeContentVariants } from './tree.variants';\n\n@Component({\n  selector: 'z-tree-node-content',\n  template: `\n    <ng-content />\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  host: {\n    '[class]': 'classes()',\n  },\n  exportAs: 'zTreeNodeContent',\n})\nexport class ZardTreeNodeContentComponent {\n  private readonly treeService = inject(ZardTreeService);\n\n  readonly class = input<ClassValue>('');\n  readonly nodeKey = input.required<string>();\n\n  readonly isSelected = computed(() => this.treeService.isSelected(this.nodeKey()));\n\n  protected readonly classes = computed(() =>\n    mergeClasses(treeNodeContentVariants({ isSelected: this.isSelected() }), this.class()),\n  );\n}\n"
    },
    {
      "name": "tree.service.ts",
      "content": "import { computed, Injectable, signal } from '@angular/core';\n\nimport type { FlatTreeNode, TreeCheckState, TreeNode } from './tree.types';\n\n@Injectable()\nexport class ZardTreeService<T = any> {\n  readonly expandedKeys = signal<Set<string>>(new Set());\n  readonly selectedKeys = signal<Set<string>>(new Set());\n  readonly checkedKeys = signal<Set<string>>(new Set());\n  readonly indeterminateKeys = signal<Set<string>>(new Set());\n\n  private readonly dataSignal = signal<TreeNode<T>[]>([]);\n\n  // Click notification from tree-node → tree component (to emit zNodeClick output)\n  private _clickId = 0;\n  readonly clickedNode = signal<{ node: TreeNode<T>; _id: number } | null>(null);\n\n  notifyNodeClick(node: TreeNode<T>) {\n    this.clickedNode.set({ node, _id: ++this._clickId });\n  }\n\n  readonly flattenedNodes = computed(() => {\n    const result: FlatTreeNode<T>[] = [];\n    let index = 0;\n    const flatten = (nodes: TreeNode<T>[], level: number) => {\n      for (const node of nodes) {\n        const expandable = !node.leaf && !!node.children?.length;\n        result.push({ node, level, expandable, index: index++ });\n        if (expandable && this.expandedKeys().has(node.key)) {\n          flatten(node.children!, level + 1);\n        }\n      }\n    };\n    flatten(this.dataSignal(), 0);\n    return result;\n  });\n\n  setData(data: TreeNode<T>[]) {\n    this.dataSignal.set(data);\n  }\n\n  // --- Expand / Collapse ---\n\n  isExpanded(key: string): boolean {\n    return this.expandedKeys().has(key);\n  }\n\n  toggle(key: string) {\n    if (this.isExpanded(key)) {\n      this.collapse(key);\n    } else {\n      this.expand(key);\n    }\n  }\n\n  expand(key: string) {\n    this.expandedKeys.update(keys => {\n      const next = new Set(keys);\n      next.add(key);\n      return next;\n    });\n  }\n\n  collapse(key: string) {\n    this.expandedKeys.update(keys => {\n      const next = new Set(keys);\n      next.delete(key);\n      return next;\n    });\n  }\n\n  expandAll() {\n    const allKeys = new Set<string>();\n    const collect = (nodes: TreeNode<T>[]) => {\n      for (const node of nodes) {\n        if (!node.leaf && node.children?.length) {\n          allKeys.add(node.key);\n          collect(node.children);\n        }\n      }\n    };\n    collect(this.dataSignal());\n    this.expandedKeys.set(allKeys);\n  }\n\n  collapseAll() {\n    this.expandedKeys.set(new Set());\n  }\n\n  // --- Selection ---\n\n  isSelected(key: string): boolean {\n    return this.selectedKeys().has(key);\n  }\n\n  select(key: string, mode: 'single' | 'multiple') {\n    if (mode === 'single') {\n      this.selectedKeys.set(new Set([key]));\n    } else {\n      this.selectedKeys.update(keys => {\n        const next = new Set(keys);\n        if (next.has(key)) {\n          next.delete(key);\n        } else {\n          next.add(key);\n        }\n        return next;\n      });\n    }\n  }\n\n  deselect(key: string) {\n    this.selectedKeys.update(keys => {\n      const next = new Set(keys);\n      next.delete(key);\n      return next;\n    });\n  }\n\n  getSelectedNodes(): TreeNode<T>[] {\n    const selected: TreeNode<T>[] = [];\n    const collect = (nodes: TreeNode<T>[]) => {\n      for (const node of nodes) {\n        if (this.selectedKeys().has(node.key)) {\n          selected.push(node);\n        }\n        if (node.children?.length) {\n          collect(node.children);\n        }\n      }\n    };\n    collect(this.dataSignal());\n    return selected;\n  }\n\n  // --- Checkbox with propagation ---\n\n  getCheckState(key: string): TreeCheckState {\n    if (this.checkedKeys().has(key)) {\n      return 'checked';\n    }\n    if (this.indeterminateKeys().has(key)) {\n      return 'indeterminate';\n    }\n    return 'unchecked';\n  }\n\n  toggleCheck(node: TreeNode<T>) {\n    const isChecked = this.checkedKeys().has(node.key);\n    if (isChecked) {\n      this.uncheckNode(node);\n    } else {\n      this.checkNode(node);\n    }\n    this.updateAncestors(this.dataSignal());\n  }\n\n  private checkNode(node: TreeNode<T>) {\n    this.checkedKeys.update(keys => {\n      const next = new Set(keys);\n      next.add(node.key);\n      return next;\n    });\n    this.indeterminateKeys.update(keys => {\n      const next = new Set(keys);\n      next.delete(node.key);\n      return next;\n    });\n    if (node.children?.length) {\n      for (const child of node.children) {\n        if (!child.disabled) {\n          this.checkNode(child);\n        }\n      }\n    }\n  }\n\n  private uncheckNode(node: TreeNode<T>) {\n    this.checkedKeys.update(keys => {\n      const next = new Set(keys);\n      next.delete(node.key);\n      return next;\n    });\n    this.indeterminateKeys.update(keys => {\n      const next = new Set(keys);\n      next.delete(node.key);\n      return next;\n    });\n    if (node.children?.length) {\n      for (const child of node.children) {\n        if (!child.disabled) {\n          this.uncheckNode(child);\n        }\n      }\n    }\n  }\n\n  private updateAncestors(nodes: TreeNode<T>[]) {\n    const checked = this.checkedKeys();\n    const nextIndeterminate = new Set<string>();\n\n    const computeState = (node: TreeNode<T>): 'checked' | 'unchecked' | 'indeterminate' => {\n      if (!node.children?.length) {\n        return checked.has(node.key) ? 'checked' : 'unchecked';\n      }\n\n      const childStates = node.children.filter(c => !c.disabled).map(c => computeState(c));\n\n      const allChecked = childStates.length > 0 && childStates.every(s => s === 'checked');\n      const someChecked = childStates.some(s => s === 'checked' || s === 'indeterminate');\n\n      if (allChecked) {\n        this.checkedKeys.update(keys => {\n          const next = new Set(keys);\n          next.add(node.key);\n          return next;\n        });\n        return 'checked';\n      } else if (someChecked) {\n        this.checkedKeys.update(keys => {\n          const next = new Set(keys);\n          next.delete(node.key);\n          return next;\n        });\n        nextIndeterminate.add(node.key);\n        return 'indeterminate';\n      } else {\n        this.checkedKeys.update(keys => {\n          const next = new Set(keys);\n          next.delete(node.key);\n          return next;\n        });\n        return 'unchecked';\n      }\n    };\n\n    for (const node of nodes) {\n      computeState(node);\n    }\n\n    this.indeterminateKeys.set(nextIndeterminate);\n  }\n\n  getCheckedNodes(): TreeNode<T>[] {\n    const result: TreeNode<T>[] = [];\n    const collect = (nodes: TreeNode<T>[]) => {\n      for (const node of nodes) {\n        if (this.checkedKeys().has(node.key)) {\n          result.push(node);\n        }\n        if (node.children?.length) {\n          collect(node.children);\n        }\n      }\n    };\n    collect(this.dataSignal());\n    return result;\n  }\n\n  // --- Helpers ---\n\n  findNode(key: string, nodes?: TreeNode<T>[]): TreeNode<T> | null {\n    for (const node of nodes ?? this.dataSignal()) {\n      if (node.key === key) {\n        return node;\n      }\n      if (node.children?.length) {\n        const found = this.findNode(key, node.children);\n        if (found) {\n          return found;\n        }\n      }\n    }\n    return null;\n  }\n}\n"
    },
    {
      "name": "tree.types.ts",
      "content": "export interface TreeNode<T = any> {\n  key: string;\n  label: string;\n  data?: T;\n  icon?: string;\n  children?: TreeNode<T>[];\n  expanded?: boolean;\n  selected?: boolean;\n  checked?: boolean;\n  disabled?: boolean;\n  leaf?: boolean;\n}\n\nexport interface TreeNodeTemplateContext<T = unknown> {\n  $implicit: TreeNode<T>;\n  level: number;\n}\n\nexport type TreeCheckState = 'checked' | 'unchecked' | 'indeterminate';\n\nexport interface FlatTreeNode<T = any> {\n  node: TreeNode<T>;\n  level: number;\n  expandable: boolean;\n  index: number;\n}\n"
    },
    {
      "name": "tree.variants.ts",
      "content": "import { cva, type VariantProps } from 'class-variance-authority';\n\nexport const treeVariants = cva('flex flex-col text-sm', {\n  variants: {},\n  defaultVariants: {},\n});\n\nexport const treeNodeVariants = cva('flex flex-col', {\n  variants: {\n    disabled: {\n      true: 'opacity-50 pointer-events-none',\n      false: '',\n    },\n  },\n  defaultVariants: {\n    disabled: false,\n  },\n});\n\nexport const treeNodeToggleVariants = cva(\n  'inline-flex size-4 shrink-0 items-center justify-center rounded-sm transition-transform duration-200 hover:bg-accent focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring',\n  {\n    variants: {\n      isExpanded: {\n        true: 'rotate-90',\n        false: 'rotate-0',\n      },\n    },\n    defaultVariants: {\n      isExpanded: false,\n    },\n  },\n);\n\nexport const treeNodeContentVariants = cva(\n  'flex flex-1 items-center gap-2 rounded-sm px-2 py-1.5 text-sm cursor-pointer select-none transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring',\n  {\n    variants: {\n      isSelected: {\n        true: 'bg-accent text-accent-foreground',\n        false: '',\n      },\n    },\n    defaultVariants: {\n      isSelected: false,\n    },\n  },\n);\n\nexport const treeNodeChildrenVariants = cva('grid transition-all duration-200 ease-in-out', {\n  variants: {\n    isExpanded: {\n      true: 'grid-rows-[1fr]',\n      false: 'grid-rows-[0fr]',\n    },\n  },\n  defaultVariants: {\n    isExpanded: false,\n  },\n});\n\nexport type ZardTreeVariants = VariantProps<typeof treeVariants>;\nexport type ZardTreeNodeVariants = VariantProps<typeof treeNodeVariants>;\nexport type ZardTreeNodeToggleVariants = VariantProps<typeof treeNodeToggleVariants>;\nexport type ZardTreeNodeContentVariants = VariantProps<typeof treeNodeContentVariants>;\nexport type ZardTreeNodeChildrenVariants = VariantProps<typeof treeNodeChildrenVariants>;\n"
    },
    {
      "name": "tree.imports.ts",
      "content": "import { ZardTreeNodeContentComponent } from '@/shared/components/tree/tree-node-content.component';\nimport { ZardTreeNodeToggleDirective } from '@/shared/components/tree/tree-node-toggle.directive';\nimport { ZardTreeNodeComponent } from '@/shared/components/tree/tree-node.component';\nimport { ZardTreeComponent } from '@/shared/components/tree/tree.component';\n\nexport const ZardTreeImports = [\n  ZardTreeComponent,\n  ZardTreeNodeComponent,\n  ZardTreeNodeToggleDirective,\n  ZardTreeNodeContentComponent,\n] as const;\n"
    },
    {
      "name": "index.ts",
      "content": "export * from '@/shared/components/tree/tree.component';\nexport * from '@/shared/components/tree/tree-node.component';\nexport * from '@/shared/components/tree/tree-node-toggle.directive';\nexport * from '@/shared/components/tree/tree-node-content.component';\nexport * from '@/shared/components/tree/tree.service';\nexport * from '@/shared/components/tree/tree.types';\nexport * from '@/shared/components/tree/tree.variants';\nexport * from '@/shared/components/tree/tree.imports';\n"
    }
  ],
  "registryDependencies": [
    "icon",
    "checkbox"
  ],
  "docs": {
    "overview": "# Tree\n\nA hierarchical tree view for displaying nested data structures. Supports expand/collapse, single and multi-selection, checkboxes with parent/child propagation, and virtual scrolling for large datasets.\n\n## When to use\n\n- File explorers and directory browsers\n- Category management and navigation hierarchies\n- Permission trees with checkbox selection\n- Organizational charts and nested settings\n- Any nested parent-child data visualization\n\n## Features\n\n- **Expand / Collapse** — Click the chevron to toggle children visibility\n- **Selection** — Single-select mode highlights the clicked node\n- **Checkboxes** — Checkable mode with full parent/child propagation and indeterminate state\n- **Virtual Scroll** — Renders thousands of nodes efficiently with CDK virtual scrolling\n- **Keyboard Navigation** — Full arrow key navigation, Home/End, Enter to select, Space to toggle checkbox\n- **Custom Templates** — Pass an `ng-template` to customize node rendering\n- **Accessibility** — `role=\"tree\"`, `role=\"treeitem\"`, `aria-expanded`, `aria-level`, `aria-selected`, `aria-checked`\n\n## Keyboard shortcuts\n\n| Key | Action |\n|-----|--------|\n| `ArrowDown` | Move to next visible node |\n| `ArrowUp` | Move to previous visible node |\n| `ArrowRight` | Expand current node |\n| `ArrowLeft` | Collapse current node |\n| `Home` | Jump to first node |\n| `End` | Jump to last visible node |\n| `Enter` | Select current node |\n| `Space` | Toggle checkbox on current node |\n",
    "api": "# API Reference\n\n[z-tree] Component\n\nz-tree is the root container for a hierarchical tree view.\n\n| Property             | Description                              | Type              | Default |\n| -------------------- | ---------------------------------------- | ----------------- | ------- |\n| `[class]`            | Custom CSS classes                       | `string`          | `''`    |\n| `[zData]`            | Tree data source                         | `TreeNode<T>[]`   | `[]`    |\n| `[zSelectable]`      | Enable node selection on click           | `boolean`         | `false` |\n| `[zCheckable]`       | Enable checkbox selection with propagation | `boolean`       | `false` |\n| `[zExpandAll]`       | Expand all nodes initially               | `boolean`         | `false` |\n| `[zVirtualScroll]`   | Enable virtual scrolling for large trees | `boolean`         | `false` |\n| `[zVirtualItemSize]` | Virtual scroll item height in pixels     | `number`          | `32`    |\n\n| Event                | Description               | Type              |\n| -------------------- | ------------------------- | ----------------- |\n| `(zNodeClick)`       | Node clicked              | `TreeNode<T>`     |\n| `(zNodeExpand)`      | Node expanded             | `TreeNode<T>`     |\n| `(zNodeCollapse)`    | Node collapsed            | `TreeNode<T>`     |\n| `(zSelectionChange)` | Selection changed          | `TreeNode<T>[]`   |\n| `(zCheckChange)`     | Checked nodes changed      | `TreeNode<T>[]`   |\n\n[TreeNode] Interface\n\nThe data model for each node in the tree.\n\n| Property   | Description                            | Type              | Required |\n| ---------- | -------------------------------------- | ----------------- | -------- |\n| `key`      | Unique identifier                      | `string`          | Yes      |\n| `label`    | Display text                           | `string`          | Yes      |\n| `data`     | Custom data payload                    | `T`               | No       |\n| `icon`     | Lucide icon name                       | `string`          | No       |\n| `children` | Child nodes                            | `TreeNode<T>[]`   | No       |\n| `expanded` | Initially expanded                     | `boolean`         | No       |\n| `selected` | Initially selected                     | `boolean`         | No       |\n| `checked`  | Initially checked                      | `boolean`         | No       |\n| `disabled` | Disable interactions                   | `boolean`         | No       |\n| `leaf`     | Mark as leaf (hides expand toggle)     | `boolean`         | No       |\n"
  },
  "demos": [
    {
      "name": "basic.ts",
      "content": "import { ChangeDetectionStrategy, Component } from '@angular/core';\n\nimport { ZardTreeImports } from '@/shared/components/tree/tree.imports';\nimport type { TreeNode } from '@/shared/components/tree/tree.types';\n\n@Component({\n  selector: 'z-demo-tree-basic',\n  imports: [ZardTreeImports],\n  template: `\n    <z-tree [zData]=\"fileSystem\" class=\"w-full max-w-sm\" />\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class ZardDemoTreeBasicComponent {\n  readonly fileSystem: TreeNode[] = [\n    {\n      key: 'src',\n      label: 'src',\n      icon: 'folder',\n      children: [\n        {\n          key: 'app',\n          label: 'app',\n          icon: 'folder',\n          children: [\n            { key: 'app.component.ts', label: 'app.component.ts', icon: 'file', leaf: true },\n            { key: 'app.component.html', label: 'app.component.html', icon: 'file', leaf: true },\n            { key: 'app.module.ts', label: 'app.module.ts', icon: 'file', leaf: true },\n          ],\n        },\n        {\n          key: 'assets',\n          label: 'assets',\n          icon: 'folder',\n          children: [{ key: 'logo.svg', label: 'logo.svg', icon: 'file', leaf: true }],\n        },\n        { key: 'main.ts', label: 'main.ts', icon: 'file', leaf: true },\n        { key: 'index.html', label: 'index.html', icon: 'file', leaf: true },\n      ],\n    },\n    {\n      key: 'package.json',\n      label: 'package.json',\n      icon: 'file',\n      leaf: true,\n    },\n    {\n      key: 'tsconfig.json',\n      label: 'tsconfig.json',\n      icon: 'file',\n      leaf: true,\n    },\n    {\n      key: 'README.md',\n      label: 'README.md',\n      icon: 'file',\n      leaf: true,\n    },\n  ];\n}\n"
    },
    {
      "name": "checkable.ts",
      "content": "import { ChangeDetectionStrategy, Component } from '@angular/core';\n\nimport { ZardTreeImports } from '@/shared/components/tree/tree.imports';\nimport type { TreeNode } from '@/shared/components/tree/tree.types';\n\n@Component({\n  selector: 'z-demo-tree-checkable',\n  imports: [ZardTreeImports],\n  template: `\n    <z-tree [zData]=\"permissions\" zCheckable (zCheckChange)=\"onCheckChange($event)\" class=\"w-full max-w-sm\" />\n    <p class=\"text-muted-foreground mt-4 text-sm\">Checked: {{ checkedLabels }}</p>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class ZardDemoTreeCheckableComponent {\n  checkedLabels = 'None';\n\n  readonly permissions: TreeNode[] = [\n    {\n      key: 'admin',\n      label: 'Administration',\n      children: [\n        {\n          key: 'users',\n          label: 'User Management',\n          children: [\n            { key: 'users-create', label: 'Create Users', leaf: true },\n            { key: 'users-edit', label: 'Edit Users', leaf: true },\n            { key: 'users-delete', label: 'Delete Users', leaf: true },\n          ],\n        },\n        {\n          key: 'roles',\n          label: 'Role Management',\n          children: [\n            { key: 'roles-create', label: 'Create Roles', leaf: true },\n            { key: 'roles-edit', label: 'Edit Roles', leaf: true },\n          ],\n        },\n      ],\n    },\n    {\n      key: 'content',\n      label: 'Content',\n      children: [\n        { key: 'content-view', label: 'View Content', leaf: true },\n        { key: 'content-edit', label: 'Edit Content', leaf: true },\n        { key: 'content-publish', label: 'Publish Content', leaf: true },\n      ],\n    },\n  ];\n\n  onCheckChange(nodes: TreeNode[]) {\n    const labels = nodes.filter(n => n.leaf).map(n => n.label);\n    this.checkedLabels = labels.length ? labels.join(', ') : 'None';\n  }\n}\n"
    },
    {
      "name": "selection.ts",
      "content": "import { ChangeDetectionStrategy, Component } from '@angular/core';\n\nimport { ZardTreeImports } from '@/shared/components/tree/tree.imports';\nimport type { TreeNode } from '@/shared/components/tree/tree.types';\n\n@Component({\n  selector: 'z-demo-tree-selection',\n  imports: [ZardTreeImports],\n  template: `\n    <z-tree\n      [zData]=\"categories\"\n      zSelectable\n      (zSelectionChange)=\"onSelect($event)\"\n      (zNodeClick)=\"onNodeClick($event)\"\n      class=\"w-full max-w-sm\"\n    />\n    <p class=\"text-muted-foreground mt-4 text-sm\">Selected: {{ selectedLabel }}</p>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class ZardDemoTreeSelectionComponent {\n  selectedLabel = 'None';\n\n  readonly categories: TreeNode[] = [\n    {\n      key: 'electronics',\n      label: 'Electronics',\n      icon: 'monitor',\n      children: [\n        {\n          key: 'phones',\n          label: 'Phones',\n          icon: 'smartphone',\n          children: [\n            { key: 'iphone', label: 'iPhone', leaf: true },\n            { key: 'samsung', label: 'Samsung Galaxy', leaf: true },\n            { key: 'pixel', label: 'Google Pixel', leaf: true },\n          ],\n        },\n        {\n          key: 'laptops',\n          label: 'Laptops',\n          icon: 'tablet',\n          children: [\n            { key: 'macbook', label: 'MacBook Pro', leaf: true },\n            { key: 'thinkpad', label: 'ThinkPad', leaf: true },\n          ],\n        },\n      ],\n    },\n    {\n      key: 'clothing',\n      label: 'Clothing',\n      icon: 'tag',\n      children: [\n        { key: 'mens', label: \"Men's\", leaf: true },\n        { key: 'womens', label: \"Women's\", leaf: true },\n      ],\n    },\n  ];\n\n  onSelect(nodes: TreeNode[]) {\n    this.selectedLabel = nodes.map(n => n.label).join(', ') || 'None';\n  }\n\n  onNodeClick(_node: TreeNode) {\n    // Handle node click\n  }\n}\n"
    },
    {
      "name": "virtual-scroll.ts",
      "content": "import { ChangeDetectionStrategy, Component } from '@angular/core';\n\nimport { ZardTreeImports } from '@/shared/components/tree/tree.imports';\nimport type { TreeNode } from '@/shared/components/tree/tree.types';\n\n@Component({\n  selector: 'z-demo-tree-virtual-scroll',\n  imports: [ZardTreeImports],\n  template: `\n    <z-tree\n      [zData]=\"largeTree\"\n      zVirtualScroll\n      [zVirtualItemSize]=\"32\"\n      zExpandAll\n      class=\"h-[400px] w-full max-w-md rounded-md border\"\n    />\n    <p class=\"text-muted-foreground mt-4 text-sm\">{{ nodeCount }} total nodes with virtual scrolling</p>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class ZardDemoTreeVirtualScrollComponent {\n  readonly largeTree: TreeNode[];\n  readonly nodeCount: number;\n\n  constructor() {\n    this.largeTree = this.generateTree(100, 3);\n    this.nodeCount = this.countNodes(this.largeTree);\n  }\n\n  private generateTree(breadth: number, depth: number, prefix = '', level = 0): TreeNode[] {\n    if (depth === 0) {\n      return [];\n    }\n    return Array.from({ length: breadth }, (_, i) => {\n      const key = prefix ? `${prefix}-${i}` : `${i}`;\n      const children = depth > 1 ? this.generateTree(Math.min(breadth, 5), depth - 1, key, level + 1) : [];\n      return {\n        key,\n        label: children.length > 0 ? `Folder ${key}` : `File ${key}`,\n        icon: children.length > 0 ? 'folder' : ('file' as string | undefined),\n        leaf: children.length === 0,\n        children: children.length > 0 ? children : undefined,\n      };\n    });\n  }\n\n  private countNodes(nodes: TreeNode[]): number {\n    let count = 0;\n    for (const node of nodes) {\n      count++;\n      if (node.children) {\n        count += this.countNodes(node.children);\n      }\n    }\n    return count;\n  }\n}\n"
    }
  ]
}
