{
  "name": "slider",
  "type": "registry:component",
  "files": [
    {
      "name": "slider.component.ts",
      "content": "import { DOCUMENT } from '@angular/common';\nimport {\n  type AfterViewInit,\n  booleanAttribute,\n  ChangeDetectionStrategy,\n  Component,\n  computed,\n  ElementRef,\n  forwardRef,\n  inject,\n  input,\n  linkedSignal,\n  numberAttribute,\n  type OnChanges,\n  type OnDestroy,\n  output,\n  signal,\n  type SimpleChanges,\n  viewChild,\n  ViewEncapsulation,\n} from '@angular/core';\nimport { type ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\n\nimport type { ClassValue } from 'clsx';\nimport { filter, fromEvent, map, Subject, switchMap, takeUntil, tap } from 'rxjs';\n\nimport {\n  sliderOrientationVariants,\n  sliderRangeVariants,\n  sliderThumbVariants,\n  sliderTrackVariants,\n  sliderVariants,\n} from './slider.variants';\n\nimport { clamp, convertValueToPercentage, roundToStep } from '@/shared/utils/number';\nimport { mergeClasses } from '@/shared/utils/merge-classes';\n\ntype OnTouchedType = () => void;\ntype OnChangeType = (value: number) => void;\n\n@Component({\n  selector: 'z-slider-track',\n  imports: [],\n  standalone: true,\n  template: `\n    <span #track data-slot=\"slider-track\" [attr.data-orientation]=\"orientation()\" [class]=\"classes()\">\n      <ng-content />\n    </span>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  host: {\n    '[class]': '\"data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full\"',\n    '[attr.data-orientation]': 'orientation()',\n  },\n})\nexport class ZSliderTrackComponent {\n  readonly orientation = input<'horizontal' | 'vertical'>('horizontal');\n  readonly class = input<ClassValue>('');\n\n  protected readonly classes = computed(() =>\n    mergeClasses(sliderTrackVariants({ zOrientation: this.orientation() }), this.class()),\n  );\n\n  private readonly trackEl = viewChild.required<ElementRef<HTMLElement>>('track');\n\n  get nativeElement(): HTMLElement {\n    return this.trackEl().nativeElement;\n  }\n}\n\n@Component({\n  selector: 'z-slider-range',\n  imports: [],\n  standalone: true,\n  template: `\n    <span\n      data-slot=\"slider-range\"\n      [attr.data-orientation]=\"orientation()\"\n      [class]=\"classes()\"\n      [style.left]=\"orientation() === 'horizontal' ? '0' : null\"\n      [style.right]=\"orientation() === 'horizontal' ? 100 - percent() + '%' : null\"\n      [style.bottom]=\"orientation() === 'vertical' ? '0' : null\"\n      [style.top]=\"orientation() === 'vertical' ? 100 - percent() + '%' : null\"\n    ></span>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n})\nexport class ZSliderRangeComponent {\n  readonly percent = input(0);\n\n  readonly orientation = input<'horizontal' | 'vertical'>('horizontal');\n  readonly class = input<ClassValue>('');\n\n  protected readonly classes = computed(() =>\n    mergeClasses(sliderRangeVariants({ zOrientation: this.orientation() }), this.class()),\n  );\n}\n\n@Component({\n  selector: 'z-slider-thumb',\n  imports: [],\n  standalone: true,\n  template: `\n    <span\n      #thumb\n      data-slot=\"slider-thumb\"\n      [attr.role]=\"'slider'\"\n      [attr.aria-valuemin]=\"min()\"\n      [attr.aria-valuemax]=\"max()\"\n      [attr.aria-valuenow]=\"value()\"\n      [attr.aria-disabled]=\"disabled() ? true : null\"\n      [class]=\"classes()\"\n      tabindex=\"0\"\n    ></span>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  host: {\n    '[class]': 'orientationClasses()',\n    '[style.left]': 'orientation() === \"horizontal\" ? \"calc(\" + percent() + \"% + \" + offset() + \"px)\" : null',\n    '[style.bottom]': 'orientation() === \"vertical\" ? \"calc(\" + percent() + \"% + \" + offset() + \"px)\" : null',\n  },\n})\nexport class ZSliderThumbComponent {\n  readonly value = input(0);\n  readonly min = input(0);\n  readonly max = input(100);\n  readonly disabled = input(false);\n  readonly percent = input(0);\n  readonly offset = input(0);\n\n  readonly orientation = input<'horizontal' | 'vertical'>('horizontal');\n  readonly class = input<ClassValue>('');\n\n  protected readonly classes = computed(() =>\n    mergeClasses(sliderThumbVariants({ disabled: this.disabled() }), this.class()),\n  );\n\n  protected readonly orientationClasses = computed(() =>\n    mergeClasses(sliderOrientationVariants({ zOrientation: this.orientation() })),\n  );\n\n  private readonly thumbEl = viewChild.required<ElementRef<HTMLElement>>('thumb');\n\n  get nativeElement(): HTMLElement {\n    return this.thumbEl().nativeElement;\n  }\n}\n\n@Component({\n  selector: 'z-slider',\n  imports: [ZSliderTrackComponent, ZSliderRangeComponent, ZSliderThumbComponent],\n  standalone: true,\n  template: `\n    <span\n      data-slot=\"slider\"\n      [attr.data-orientation]=\"zOrientation()\"\n      class=\"flex data-[orientation=horizontal]:w-full data-[orientation=horizontal]:items-center data-[orientation=vertical]:h-full data-[orientation=vertical]:justify-center\"\n    >\n      <z-slider-track [orientation]=\"zOrientation()\">\n        <z-slider-range [orientation]=\"zOrientation()\" [percent]=\"percentValue()\" />\n      </z-slider-track>\n\n      <z-slider-thumb\n        tabindex=\"0\"\n        [orientation]=\"zOrientation()\"\n        [percent]=\"percentValue()\"\n        [offset]=\"thumbOffset()\"\n        [value]=\"lastEmittedValue()\"\n        [min]=\"zMin()\"\n        [max]=\"zMax()\"\n        [disabled]=\"disabled()\"\n        (keydown.{home,end,arrowleft,arrowright,arrowdown,arrowup}.prevent)=\"handleKeydown($event)\"\n      />\n    </span>\n  `,\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => ZardSliderComponent),\n      multi: true,\n    },\n  ],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  host: {\n    '[class]': 'classes()',\n    '[attr.data-orientation]': 'zOrientation()',\n    '[attr.aria-disabled]': 'disabled() ? true : null',\n    '[attr.data-disabled]': 'disabled() ? true : null',\n  },\n  exportAs: 'zSlider',\n})\nexport class ZardSliderComponent implements ControlValueAccessor, AfterViewInit, OnChanges, OnDestroy {\n  readonly zMin = input(0, { transform: numberAttribute });\n  readonly zMax = input(100, { transform: numberAttribute });\n  readonly zDefault = input(0, { transform: numberAttribute });\n  readonly zValue = input(null, { transform: numberAttribute });\n  readonly zStep = input(1, { transform: numberAttribute });\n  readonly zDisabled = input(false, { transform: booleanAttribute });\n\n  readonly zOrientation = input<'horizontal' | 'vertical'>('horizontal');\n  readonly class = input<ClassValue>('');\n\n  readonly zSlideIndexChange = output<number>();\n\n  readonly thumbRef = viewChild.required(ZSliderThumbComponent);\n  readonly trackRef = viewChild.required(ZSliderTrackComponent);\n\n  private elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  private document = inject(DOCUMENT);\n\n  protected readonly classes = computed(() =>\n    mergeClasses(sliderVariants({ orientation: this.zOrientation() }), this.class()),\n  );\n\n  protected readonly disabled = linkedSignal(() => this.zDisabled());\n\n  readonly percentValue = signal(50);\n  readonly lastEmittedValue = signal(0);\n\n  readonly thumbOffset = signal(0);\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  private onTouched: OnTouchedType = () => {};\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  private onChange: OnChangeType = () => {};\n\n  private destroy$ = new Subject<void>();\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if ('zValue' in changes && !changes['zValue'].firstChange) {\n      const value = this.zValue();\n      if (value !== this.lastEmittedValue()) {\n        this.setInitialValue();\n      }\n    }\n  }\n\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n\n  ngAfterViewInit() {\n    const pointerDown$ = fromEvent<PointerEvent>(this.elementRef.nativeElement, 'pointerdown').pipe(\n      filter(() => !this.disabled()),\n      tap(event => {\n        const target = event.target as HTMLElement;\n        const isThumb = this.thumbRef().nativeElement.contains(target);\n        const isTrack = this.trackRef().nativeElement.contains(target);\n\n        if (isTrack && !isThumb) {\n          const coord = this.zOrientation() === 'vertical' ? event.clientY : event.clientX;\n          const clickPercentage = this.calculatePercentage(coord);\n          this.updateSliderFromPercentage(clickPercentage);\n          this.onTouched();\n          requestAnimationFrame(() => {\n            this.thumbRef().nativeElement.focus();\n          });\n        }\n      }),\n    );\n\n    const pointerMove$ = fromEvent<PointerEvent>(this.document, 'pointermove');\n    const pointerUp$ = fromEvent<PointerEvent>(this.document, 'pointerup');\n\n    pointerDown$\n      .pipe(\n        switchMap(() =>\n          pointerMove$.pipe(\n            takeUntil(pointerUp$),\n            map(event => {\n              const coord = this.zOrientation() === 'vertical' ? event.clientY : event.clientX;\n              return this.calculatePercentage(coord);\n            }),\n          ),\n        ),\n        takeUntil(this.destroy$),\n      )\n      .subscribe(percentage => {\n        if (this.disabled()) {\n          return;\n        }\n        this.updateSliderFromPercentage(percentage);\n        this.onTouched();\n      });\n\n    this.setInitialValue();\n  }\n\n  writeValue(value: number): void {\n    if (value == null) {\n      this.setInitialValue();\n      return;\n    }\n\n    const min = this.zMin();\n    const max = this.zMax();\n    const step = this.zStep();\n\n    const clampedValue = clamp(value, [min, max]);\n    const roundedValue = roundToStep(clampedValue, min, step);\n\n    if (roundedValue === this.lastEmittedValue()) {\n      return;\n    }\n\n    this.percentValue.set(convertValueToPercentage(roundedValue, min, max));\n    this.lastEmittedValue.set(roundedValue);\n  }\n\n  registerOnChange(fn: (value: number) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled.set(isDisabled);\n  }\n\n  handleKeydown(event: Event): void {\n    if (this.disabled()) {\n      return;\n    }\n\n    const percent = this.percentValue();\n    const rawValue = this.zMin() + ((this.zMax() - this.zMin()) * percent) / 100;\n    const currentValue = roundToStep(rawValue, this.zMin(), this.zStep());\n\n    let newValue = currentValue;\n\n    const { key } = event as KeyboardEvent;\n\n    switch (key) {\n      case 'Home':\n        newValue = this.zMin();\n        break;\n      case 'End':\n        newValue = this.zMax();\n        break;\n      case 'ArrowLeft':\n      case 'ArrowDown':\n        newValue = Math.max(currentValue - this.zStep(), this.zMin());\n        break;\n      case 'ArrowRight':\n      case 'ArrowUp':\n        newValue = Math.min(currentValue + this.zStep(), this.zMax());\n        break;\n\n      default:\n        return;\n    }\n\n    if (newValue !== currentValue) {\n      this.percentValue.set(convertValueToPercentage(newValue, this.zMin(), this.zMax()));\n      this.zSlideIndexChange.emit(newValue);\n      this.lastEmittedValue.set(newValue);\n      this.onChange(newValue);\n    }\n  }\n\n  private updateSliderFromPercentage(percentage: number): void {\n    const clamped = clamp(percentage, [0, 1]);\n    const rawValue = this.zMin() + (this.zMax() - this.zMin()) * clamped;\n    const value = roundToStep(rawValue, this.zMin(), this.zStep());\n\n    if (value !== this.lastEmittedValue()) {\n      this.percentValue.set(convertValueToPercentage(value, this.zMin(), this.zMax()));\n      this.zSlideIndexChange.emit(value);\n      this.lastEmittedValue.set(value);\n      this.onChange(value);\n    }\n  }\n\n  private calculatePercentage(clientCoord: number): number {\n    const rect = this.elementRef.nativeElement.getBoundingClientRect();\n    if (this.zOrientation() === 'vertical') {\n      const relativeY = (clientCoord - rect.top) / rect.height;\n      return clamp(1 - relativeY, [0, 1]);\n    }\n    const relativeX = (clientCoord - rect.left) / rect.width;\n    return clamp(relativeX, [0, 1]);\n  }\n\n  private setInitialValue(): void {\n    const min = this.zMin();\n    const max = this.zMax();\n    const step = this.zStep();\n\n    const def = clamp(this.zDefault(), [min, max]);\n    const raw = this.zValue();\n    const value = raw != null && raw >= min && raw <= max ? raw : def;\n\n    const initial = roundToStep(value, min, step);\n    this.percentValue.set(convertValueToPercentage(initial, min, max));\n    this.lastEmittedValue.set(initial);\n    this.thumbOffset.set(0);\n  }\n}\n"
    },
    {
      "name": "slider.variants.ts",
      "content": "import { cva, type VariantProps } from 'class-variance-authority';\n\nexport const sliderVariants = cva(\n  'relative flex w-full touch-none items-center select-none data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col',\n  {\n    variants: {\n      orientation: {\n        horizontal: 'items-center',\n        vertical: 'flex-col h-full min-h-44 w-auto',\n      },\n      disabled: {\n        true: 'opacity-50 pointer-events-none',\n        false: '',\n      },\n    },\n    defaultVariants: {\n      orientation: 'horizontal',\n      disabled: false,\n    },\n  },\n);\n\nexport type SliderVariants = VariantProps<typeof sliderVariants>;\n\nexport const sliderTrackVariants = cva(\n  'flex bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-1.5 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5',\n  {\n    variants: {\n      zOrientation: {\n        horizontal: 'h-1.5 w-full',\n        vertical: 'w-1.5 h-full min-h-44',\n      },\n    },\n    defaultVariants: {\n      zOrientation: 'horizontal',\n    },\n  },\n);\n\nexport type SliderTrackVariants = VariantProps<typeof sliderTrackVariants>;\n\nexport const sliderRangeVariants = cva(\n  'bg-primary absolute data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full',\n  {\n    variants: {\n      zOrientation: {\n        horizontal: 'h-full',\n        vertical: 'w-full',\n      },\n    },\n    defaultVariants: {\n      zOrientation: 'horizontal',\n    },\n  },\n);\n\nexport type SliderRangeVariants = VariantProps<typeof sliderRangeVariants>;\n\nexport const sliderThumbVariants = cva(\n  'border-primary bg-background ring-ring/50 block size-4 shrink-0 rounded-full border shadow-sm transition-[color,box-shadow] focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50',\n  {\n    variants: {\n      disabled: {\n        true: '',\n        false: 'hover:ring-4',\n      },\n    },\n  },\n);\n\nexport type SliderThumbVariants = VariantProps<typeof sliderThumbVariants>;\n\nexport const sliderOrientationVariants = cva('absolute', {\n  variants: {\n    zOrientation: {\n      horizontal: 'translate-x-[-50%]',\n      vertical: 'translate-y-[50%]',\n    },\n  },\n  defaultVariants: {\n    zOrientation: 'horizontal',\n  },\n});\n\nexport type SliderOrientationVariants = VariantProps<typeof sliderOrientationVariants>;\n"
    }
  ],
  "registryDependencies": [
    "core"
  ]
}
